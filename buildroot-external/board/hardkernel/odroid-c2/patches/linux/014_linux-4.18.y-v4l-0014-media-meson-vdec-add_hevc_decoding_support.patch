From 3ff8b6ea023464f8de12835ed90211e3f66ed0f4 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <mjourdan@baylibre.com>
Date: Wed, 29 Aug 2018 18:48:35 +0200
Subject: [PATCH] media: meson: vdec: add HEVC decoding support

Add support for V4L2_PIX_FMT_HEVC
---
 drivers/media/platform/meson/vdec/Makefile    |    4 +-
 .../media/platform/meson/vdec/codec_hevc.c    | 1517 +++++++++++++++++
 .../media/platform/meson/vdec/codec_hevc.h    |   13 +
 drivers/media/platform/meson/vdec/hevc_regs.h |  742 ++++++++
 drivers/media/platform/meson/vdec/vdec_hevc.c |  191 +++
 drivers/media/platform/meson/vdec/vdec_hevc.h |   22 +
 .../media/platform/meson/vdec/vdec_platform.c |   32 +
 7 files changed, 2519 insertions(+), 2 deletions(-)
 create mode 100644 drivers/media/platform/meson/vdec/codec_hevc.c
 create mode 100644 drivers/media/platform/meson/vdec/codec_hevc.h
 create mode 100644 drivers/media/platform/meson/vdec/hevc_regs.h
 create mode 100644 drivers/media/platform/meson/vdec/vdec_hevc.c
 create mode 100644 drivers/media/platform/meson/vdec/vdec_hevc.h

diff --git a/drivers/media/platform/meson/vdec/Makefile b/drivers/media/platform/meson/vdec/Makefile
index 20c23f9015ebd..f34b7a2961511 100644
--- a/drivers/media/platform/meson/vdec/Makefile
+++ b/drivers/media/platform/meson/vdec/Makefile
@@ -2,7 +2,7 @@
 # Makefile for Amlogic meson video decoder driver
 
 meson-vdec-objs = esparser.o vdec.o vdec_helpers.o vdec_platform.o
-meson-vdec-objs += vdec_1.o
-meson-vdec-objs += codec_mpeg12.o codec_h264.o codec_mpeg4.o codec_mjpeg.o
+meson-vdec-objs += vdec_1.o vdec_hevc.o
+meson-vdec-objs += codec_mpeg12.o codec_h264.o codec_mpeg4.o codec_mjpeg.o codec_hevc.o
 
 obj-$(CONFIG_VIDEO_MESON_VDEC) += meson-vdec.o
diff --git a/drivers/media/platform/meson/vdec/codec_hevc.c b/drivers/media/platform/meson/vdec/codec_hevc.c
new file mode 100644
index 0000000000000..5e69717ba0570
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/codec_hevc.c
@@ -0,0 +1,1517 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Maxime Jourdan <maxi.jourdan@wanadoo.fr>
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ */
+
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "codec_hevc.h"
+#include "dos_regs.h"
+#include "hevc_regs.h"
+#include "vdec_helpers.h"
+
+/* HEVC reg mapping */
+#define HEVC_DEC_STATUS_REG	HEVC_ASSIST_SCRATCH_0
+	#define HEVC_ACTION_DONE	0xff
+#define HEVC_RPM_BUFFER		HEVC_ASSIST_SCRATCH_1
+#define HEVC_DECODE_INFO	HEVC_ASSIST_SCRATCH_1
+#define HEVC_SHORT_TERM_RPS	HEVC_ASSIST_SCRATCH_2
+#define HEVC_VPS_BUFFER		HEVC_ASSIST_SCRATCH_3
+#define HEVC_SPS_BUFFER		HEVC_ASSIST_SCRATCH_4
+#define HEVC_PPS_BUFFER		HEVC_ASSIST_SCRATCH_5
+#define HEVC_SAO_UP		HEVC_ASSIST_SCRATCH_6
+#define HEVC_STREAM_SWAP_BUFFER HEVC_ASSIST_SCRATCH_7
+#define H265_MMU_MAP_BUFFER	HEVC_ASSIST_SCRATCH_7
+#define HEVC_STREAM_SWAP_BUFFER2 HEVC_ASSIST_SCRATCH_8
+#define HEVC_sao_mem_unit	HEVC_ASSIST_SCRATCH_9
+#define HEVC_SAO_ABV		HEVC_ASSIST_SCRATCH_A
+#define HEVC_sao_vb_size	HEVC_ASSIST_SCRATCH_B
+#define HEVC_SAO_VB		HEVC_ASSIST_SCRATCH_C
+#define HEVC_SCALELUT		HEVC_ASSIST_SCRATCH_D
+#define HEVC_WAIT_FLAG		HEVC_ASSIST_SCRATCH_E
+#define RPM_CMD_REG		HEVC_ASSIST_SCRATCH_F
+#define LMEM_DUMP_ADR		HEVC_ASSIST_SCRATCH_F
+#define DEBUG_REG1		HEVC_ASSIST_SCRATCH_G
+#define HEVC_DECODE_MODE2	HEVC_ASSIST_SCRATCH_H
+#define NAL_SEARCH_CTL		HEVC_ASSIST_SCRATCH_I
+#define HEVC_DECODE_MODE	HEVC_ASSIST_SCRATCH_J
+	#define DECODE_MODE_SINGLE 0
+#define DECODE_STOP_POS		HEVC_ASSIST_SCRATCH_K
+#define HEVC_AUX_ADR		HEVC_ASSIST_SCRATCH_L
+#define HEVC_AUX_DATA_SIZE	HEVC_ASSIST_SCRATCH_M
+#define HEVC_DECODE_SIZE	HEVC_ASSIST_SCRATCH_N
+
+#define HEVCD_MPP_ANC2AXI_TBL_DATA (0x3464 * 4)
+
+#define HEVC_CM_BODY_START_ADDR	(0x3626 * 4)
+#define HEVC_CM_BODY_LENGTH	(0x3627 * 4)
+#define HEVC_CM_HEADER_LENGTH	(0x3629 * 4)
+#define HEVC_CM_HEADER_OFFSET	(0x362b * 4)
+
+#define AMRISC_MAIN_REQ		 0x04
+
+/* HEVC Constants */
+#define MAX_REF_PIC_NUM		24
+#define MAX_REF_ACTIVE		16
+#define MPRED_MV_BUF_SIZE	0x120000
+#define MAX_TILE_COL_NUM	10
+#define MAX_TILE_ROW_NUM	20
+#define MAX_SLICE_NUM		800
+#define INVALID_POC		0x80000000
+
+/* HEVC Workspace layout */
+#define IPP_OFFSET       0x00
+#define SAO_ABV_OFFSET   (IPP_OFFSET + 0x4000)
+#define SAO_VB_OFFSET    (SAO_ABV_OFFSET + 0x30000)
+#define SH_TM_RPS_OFFSET (SAO_VB_OFFSET + 0x30000)
+#define VPS_OFFSET       (SH_TM_RPS_OFFSET + 0x800)
+#define SPS_OFFSET       (VPS_OFFSET + 0x800)
+#define PPS_OFFSET       (SPS_OFFSET + 0x800)
+#define SAO_UP_OFFSET    (PPS_OFFSET + 0x2000)
+#define SWAP_BUF_OFFSET  (SAO_UP_OFFSET + 0x800)
+#define SWAP_BUF2_OFFSET (SWAP_BUF_OFFSET + 0x800)
+#define SCALELUT_OFFSET  (SWAP_BUF2_OFFSET + 0x800)
+#define DBLK_PARA_OFFSET (SCALELUT_OFFSET + 0x8000)
+#define DBLK_DATA_OFFSET (DBLK_PARA_OFFSET + 0x20000)
+#define MMU_VBH_OFFSET   (DBLK_DATA_OFFSET + 0x40000)
+#define MPRED_ABV_OFFSET (MMU_VBH_OFFSET + 0x5000)
+#define MPRED_MV_OFFSET  (MPRED_ABV_OFFSET + 0x8000)
+#define RPM_OFFSET       (MPRED_MV_OFFSET + MPRED_MV_BUF_SIZE * MAX_REF_PIC_NUM)
+#define LMEM_OFFSET      (RPM_OFFSET + 0x100)
+
+/* ISR decode status */
+#define HEVC_DEC_IDLE                        0x0
+#define HEVC_NAL_UNIT_VPS                    0x1
+#define HEVC_NAL_UNIT_SPS                    0x2
+#define HEVC_NAL_UNIT_PPS                    0x3
+#define HEVC_NAL_UNIT_CODED_SLICE_SEGMENT    0x4
+#define HEVC_CODED_SLICE_SEGMENT_DAT         0x5
+#define HEVC_SLICE_DECODING                  0x6
+#define HEVC_NAL_UNIT_SEI                    0x7
+#define HEVC_SLICE_SEGMENT_DONE              0x8
+#define HEVC_NAL_SEARCH_DONE                 0x9
+#define HEVC_DECPIC_DATA_DONE                0xa
+#define HEVC_DECPIC_DATA_ERROR               0xb
+#define HEVC_SEI_DAT                         0xc
+#define HEVC_SEI_DAT_DONE                    0xd
+
+/* RPM misc_flag0 */
+#define PCM_LOOP_FILTER_DISABLED_FLAG_BIT		0
+#define PCM_ENABLE_FLAG_BIT				1
+#define LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT	2
+#define PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT	3
+#define DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT	4
+#define PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT		5
+#define DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT		6
+#define SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT	7
+#define SLICE_SAO_LUMA_FLAG_BIT				8
+#define SLICE_SAO_CHROMA_FLAG_BIT			9
+#define SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT 10
+
+/* Buffer sizes */
+#define SIZE_WORKSPACE ALIGN(LMEM_OFFSET + 0xA00, 64 * SZ_1K)
+#define SIZE_AUX (SZ_1K * 16)
+#define SIZE_FRAME_MMU (0x1200 * 4)
+#define RPM_SIZE 0x80
+#define RPS_USED_BIT 14
+
+#define PARSER_CMD_SKIP_CFG_0 0x0000090b
+#define PARSER_CMD_SKIP_CFG_1 0x1b14140f
+#define PARSER_CMD_SKIP_CFG_2 0x001b1910
+static const u16 parser_cmd[] = {
+	0x0401,	0x8401,	0x0800,	0x0402,
+	0x9002,	0x1423,	0x8CC3,	0x1423,
+	0x8804,	0x9825,	0x0800,	0x04FE,
+	0x8406,	0x8411,	0x1800,	0x8408,
+	0x8409,	0x8C2A,	0x9C2B,	0x1C00,
+	0x840F,	0x8407,	0x8000,	0x8408,
+	0x2000,	0xA800,	0x8410,	0x04DE,
+	0x840C,	0x840D,	0xAC00,	0xA000,
+	0x08C0,	0x08E0,	0xA40E,	0xFC00,
+	0x7C00
+};
+
+/* Data received from the HW in this form, do not rearrange */
+union rpm_param {
+	struct {
+		u16 data[RPM_SIZE];
+	} l;
+	struct {
+		u16 CUR_RPS[MAX_REF_ACTIVE];
+		u16 num_ref_idx_l0_active;
+		u16 num_ref_idx_l1_active;
+		u16 slice_type;
+		u16 slice_temporal_mvp_enable_flag;
+		u16 dependent_slice_segment_flag;
+		u16 slice_segment_address;
+		u16 num_title_rows_minus1;
+		u16 pic_width_in_luma_samples;
+		u16 pic_height_in_luma_samples;
+		u16 log2_min_coding_block_size_minus3;
+		u16 log2_diff_max_min_coding_block_size;
+		u16 log2_max_pic_order_cnt_lsb_minus4;
+		u16 POClsb;
+		u16 collocated_from_l0_flag;
+		u16 collocated_ref_idx;
+		u16 log2_parallel_merge_level;
+		u16 five_minus_max_num_merge_cand;
+		u16 sps_num_reorder_pics_0;
+		u16 modification_flag;
+		u16 tiles_flags;
+		u16 num_tile_columns_minus1;
+		u16 num_tile_rows_minus1;
+		u16 tile_width[8];
+		u16 tile_height[8];
+		u16 misc_flag0;
+		u16 pps_beta_offset_div2;
+		u16 pps_tc_offset_div2;
+		u16 slice_beta_offset_div2;
+		u16 slice_tc_offset_div2;
+		u16 pps_cb_qp_offset;
+		u16 pps_cr_qp_offset;
+		u16 first_slice_segment_in_pic_flag;
+		u16 m_temporalId;
+		u16 m_nalUnitType;
+		u16 vui_num_units_in_tick_hi;
+		u16 vui_num_units_in_tick_lo;
+		u16 vui_time_scale_hi;
+		u16 vui_time_scale_lo;
+		u16 bit_depth;
+		u16 profile_etc;
+		u16 sei_frame_field_info;
+		u16 video_signal_type;
+		u16 modification_list[0x20];
+		u16 conformance_window_flag;
+		u16 conf_win_left_offset;
+		u16 conf_win_right_offset;
+		u16 conf_win_top_offset;
+		u16 conf_win_bottom_offset;
+		u16 chroma_format_idc;
+		u16 color_description;
+		u16 aspect_ratio_idc;
+		u16 sar_width;
+		u16 sar_height;
+	} p;
+};
+
+enum nal_unit_type {
+	NAL_UNIT_CODED_SLICE_BLA	= 16,
+	NAL_UNIT_CODED_SLICE_BLANT	= 17,
+	NAL_UNIT_CODED_SLICE_BLA_N_LP	= 18,
+	NAL_UNIT_CODED_SLICE_IDR	= 19,
+	NAL_UNIT_CODED_SLICE_IDR_N_LP	= 20,
+};
+
+enum slice_type {
+	B_SLICE = 0,
+	P_SLICE = 1,
+	I_SLICE = 2,
+};
+
+/* A frame being decoded */
+struct hevc_frame {
+	struct list_head list;
+	struct vb2_v4l2_buffer *vbuf;
+	u32 poc;
+
+	int referenced;
+	u32 num_reorder_pic;
+
+	u32 cur_slice_idx;
+	u32 cur_slice_type;
+
+	/* 2 lists (L0/L1) ; 800 slices ; 16 refs */
+	u32 ref_poc_list[2][MAX_SLICE_NUM][MAX_REF_ACTIVE];
+	u32 ref_num[2];
+};
+
+struct hevc_tile {
+	int width;
+	int height;
+	int start_cu_x;
+	int start_cu_y;
+
+	dma_addr_t sao_vb_start_addr;
+	dma_addr_t sao_abv_start_addr;
+};
+
+struct codec_hevc {
+	/* Current decoding status provided by the ISR */
+	u32 dec_status;
+
+	struct mutex lock;
+
+	/* Buffer for the HEVC Workspace */
+	void      *workspace_vaddr;
+	dma_addr_t workspace_paddr;
+
+	/* AUX buffer */
+	void      *aux_vaddr;
+	dma_addr_t aux_paddr;
+
+	/* Frame MMU buffer (>= GXL) ; unused for now */
+	void      *frame_mmu_vaddr;
+	dma_addr_t frame_mmu_paddr;
+
+	/* Contains many information parsed from the bitstream */
+	union rpm_param rpm_param;
+
+	/* Information computed from the RPM */
+	u32 lcu_size; // Largest Coding Unit
+	u32 lcu_x_num;
+	u32 lcu_y_num;
+	u32 lcu_total;
+
+	/* Current Frame being handled */
+	struct hevc_frame *cur_frame;
+	u32 curr_poc;
+	/* Collocated Reference Picture */
+	struct hevc_frame *col_frame;
+	u32 col_poc;
+
+	/* All ref frames used by the HW at a given time */
+	struct list_head ref_frames_list;
+	u32 frames_num;
+
+	/* Resolution reported by the hardware */
+	u32 width;
+	u32 height;
+
+	u32 iPrevTid0POC;
+	u32 slice_segment_addr;
+	u32 slice_addr;
+	u32 ldc_flag;
+
+	/* Tiles */
+	u32 num_tile_col;
+	u32 num_tile_row;
+	struct hevc_tile m_tile[MAX_TILE_ROW_NUM][MAX_TILE_COL_NUM];
+	u32 tile_start_lcu_x;
+	u32 tile_start_lcu_y;
+	u32 tile_width_lcu;
+	u32 tile_height_lcu;
+
+	/* Whether we detected the bitstream as 10-bit */
+	int is_10bit;
+
+	/* Whether we already configured the buffer list in HW */
+	int is_buflist_init;
+
+	/* In case of downsampling (decoding with FBC but outputting in NV12M),
+	 * we need to allocate additional buffers for FBC.
+	 */
+	 void *fbc_buffer_vaddr[24];
+	 dma_addr_t fbc_buffer_paddr[24];
+};
+
+/* Returns 1 if we must use framebuffer compression */
+static int codec_hevc_use_fbc(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	return sess->pixfmt_cap == V4L2_PIX_FMT_AM21C || hevc->is_10bit;
+}
+
+/* Returns 1 if we are decoding 10-bit but outputting 8-bit NV12 */
+static int codec_hevc_use_downsample(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	return sess->pixfmt_cap == V4L2_PIX_FMT_NV12M && hevc->is_10bit;
+}
+
+static u32 codec_hevc_num_pending_bufs(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc;
+	u32 ret;
+
+	hevc = sess->priv;
+	if (!hevc)
+		return 0;
+
+	mutex_lock(&hevc->lock);
+	ret = hevc->frames_num;
+	mutex_unlock(&hevc->lock);
+
+	return ret;
+}
+
+/* Update the L0 and L1 reference lists for a given frame */
+static void codec_hevc_update_frame_refs(struct amvdec_session *sess, struct hevc_frame *frame)
+{
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *params = &hevc->rpm_param;
+	int i;
+	int num_neg = 0;
+	int num_pos = 0;
+	int total_num;
+	int num_ref_idx_l0_active =
+		(params->p.num_ref_idx_l0_active > MAX_REF_ACTIVE) ?
+		MAX_REF_ACTIVE : params->p.num_ref_idx_l0_active;
+	int num_ref_idx_l1_active =
+		(params->p.num_ref_idx_l1_active > MAX_REF_ACTIVE) ?
+		MAX_REF_ACTIVE : params->p.num_ref_idx_l1_active;
+	int ref_picset0[MAX_REF_ACTIVE] = { 0 };
+	int ref_picset1[MAX_REF_ACTIVE] = { 0 };
+
+	for (i = 0; i < MAX_REF_ACTIVE; i++) {
+		frame->ref_poc_list[0][frame->cur_slice_idx][i] = 0;
+		frame->ref_poc_list[1][frame->cur_slice_idx][i] = 0;
+	}
+
+	for (i = 0; i < MAX_REF_ACTIVE; i++) {
+		u16 cur_rps = params->p.CUR_RPS[i];
+		int delt = cur_rps & ((1 << (RPS_USED_BIT - 1)) - 1);
+
+		if (cur_rps & 0x8000)
+			break;
+
+		if (!((cur_rps >> RPS_USED_BIT) & 1))
+			continue;
+
+		if ((cur_rps >> (RPS_USED_BIT - 1)) & 1) {
+			ref_picset0[num_neg] =
+			       frame->poc - ((1 << (RPS_USED_BIT - 1)) - delt);
+			num_neg++;
+		} else {
+			ref_picset1[num_pos] = frame->poc + delt;
+			num_pos++;
+		}
+	}
+
+	total_num = num_neg + num_pos;
+
+	if (total_num <= 0)
+		goto end;
+
+	for (i = 0; i < num_ref_idx_l0_active; i++) {
+		int cidx;
+		if (params->p.modification_flag & 0x1)
+			cidx = params->p.modification_list[i];
+		else
+			cidx = i % total_num;
+
+		frame->ref_poc_list[0][frame->cur_slice_idx][i] =
+			cidx >= num_neg ? ref_picset1[cidx - num_neg] :
+			ref_picset0[cidx];
+	}
+
+	if (params->p.slice_type != B_SLICE)
+		goto end;
+
+	if (params->p.modification_flag & 0x2) {
+		for (i = 0; i < num_ref_idx_l1_active; i++) {
+			int cidx;
+			if (params->p.modification_flag & 0x1)
+				cidx =
+				params->p.modification_list[num_ref_idx_l0_active + i];
+			else
+				cidx = params->p.modification_list[i];
+
+			frame->ref_poc_list[1][frame->cur_slice_idx][i] =
+				(cidx >= num_pos) ? ref_picset0[cidx - num_pos]
+				: ref_picset1[cidx];
+		}
+	} else {
+		for (i = 0; i < num_ref_idx_l1_active; i++) {
+			int cidx = i % total_num;
+			frame->ref_poc_list[1][frame->cur_slice_idx][i] =
+				cidx >= num_pos ? ref_picset0[cidx - num_pos] :
+				ref_picset1[cidx];
+		}
+	}
+
+end:
+	frame->ref_num[0] = num_ref_idx_l0_active;
+	frame->ref_num[1] = num_ref_idx_l1_active;
+
+	dev_dbg(sess->core->dev,
+		"Frame %u; slice %u; slice_type %u; num_l0 %u; num_l1 %u\n",
+		frame->poc, frame->cur_slice_idx, params->p.slice_type,
+		frame->ref_num[0], frame->ref_num[1]);
+}
+
+static void codec_hevc_update_ldc_flag(struct codec_hevc *hevc)
+{
+	struct hevc_frame *frame = hevc->cur_frame;
+	u32 slice_type = frame->cur_slice_type;
+	int i;
+
+	hevc->ldc_flag = 0;
+
+	if (slice_type == I_SLICE)
+		return;
+
+	hevc->ldc_flag = 1;
+	for (i = 0; (i < frame->ref_num[0]) && hevc->ldc_flag; i++) {
+		if (frame->ref_poc_list[0][frame->cur_slice_idx][i] > frame->poc) {
+			hevc->ldc_flag = 0;
+			break;
+		}
+	}
+
+	if (slice_type == P_SLICE)
+		return;
+
+	for (i = 0; (i < frame->ref_num[1]) && hevc->ldc_flag; i++) {
+		if (frame->ref_poc_list[1][frame->cur_slice_idx][i] > frame->poc) {
+			hevc->ldc_flag = 0;
+			break;
+		}
+	}
+}
+
+/* Tag "old" frames that are no longer referenced */
+static void codec_hevc_update_referenced(struct codec_hevc *hevc)
+{
+	union rpm_param *param = &hevc->rpm_param;
+	struct hevc_frame *frame;
+	int i;
+	u32 curr_poc = hevc->curr_poc;
+
+	list_for_each_entry(frame, &hevc->ref_frames_list, list) {
+		int is_referenced = 0;
+		u32 poc_tmp;
+
+		if (!frame->referenced)
+			continue;
+
+		for (i = 0; i < MAX_REF_ACTIVE; i++) {
+			int delt;
+			if (param->p.CUR_RPS[i] & 0x8000)
+				break;
+
+			delt = param->p.CUR_RPS[i] & ((1 << (RPS_USED_BIT - 1)) - 1);
+			if (param->p.CUR_RPS[i] & (1 << (RPS_USED_BIT - 1))) {
+				poc_tmp = curr_poc - ((1 << (RPS_USED_BIT - 1)) - delt);
+			} else
+				poc_tmp = curr_poc + delt;
+			if (poc_tmp == frame->poc) {
+				is_referenced = 1;
+				break;
+			}
+		}
+
+		frame->referenced = is_referenced;
+	}
+}
+
+static struct hevc_frame *codec_hevc_get_lowest_poc_frame(struct codec_hevc *hevc)
+{
+	struct hevc_frame *tmp, *ret = NULL;
+	u32 poc = INT_MAX;
+
+	list_for_each_entry(tmp, &hevc->ref_frames_list, list) {
+		if (tmp->poc < poc) {
+			ret = tmp;
+			poc = tmp->poc;
+		}
+	}
+
+	return ret;
+}
+
+/* Try to output as many frames as possible */
+static void codec_hevc_output_frames(struct amvdec_session *sess)
+{
+	struct hevc_frame *tmp;
+	struct codec_hevc *hevc = sess->priv;
+
+	while ((tmp = codec_hevc_get_lowest_poc_frame(hevc))) {
+		if (hevc->curr_poc &&
+		 (tmp->referenced || tmp->num_reorder_pic >= hevc->frames_num))
+			break;
+
+		dev_dbg(sess->core->dev, "DONE frame poc %u; vbuf %u\n",
+			tmp->poc, tmp->vbuf->vb2_buf.index);
+		amvdec_dst_buf_done(sess, tmp->vbuf, V4L2_FIELD_NONE);
+		list_del(&tmp->list);
+		kfree(tmp);
+		hevc->frames_num--;
+	}
+}
+
+/* Configure frame buffer decompression */
+static void codec_hevc_setup_decode_head(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	u32 body_size = amvdec_am21c_body_size(sess->width, sess->height);
+	u32 head_size = amvdec_am21c_head_size(sess->width, sess->height);
+
+	if (!codec_hevc_use_fbc(sess)) {
+		/* Enable 2-plane reference read mode for MC */
+		amvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL1, BIT(31));
+		return;
+	}
+
+	amvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL1, 0);
+	amvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL2, body_size / 32);
+	amvdec_write_dos(core, HEVC_CM_BODY_LENGTH, body_size);
+	amvdec_write_dos(core, HEVC_CM_HEADER_OFFSET, body_size);
+	amvdec_write_dos(core, HEVC_CM_HEADER_LENGTH, head_size);
+}
+
+static void codec_hevc_setup_buffers_gxbb(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	struct v4l2_m2m_buffer *buf;
+	u32 buf_num = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
+	dma_addr_t buf_y_paddr = 0;
+	dma_addr_t buf_uv_paddr = 0;
+	u32 idx = 0;
+	u32 val;
+	int i;
+
+	amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0);
+
+	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
+		idx = buf->vb.vb2_buf.index;
+
+		if (codec_hevc_use_downsample(sess))
+			buf_y_paddr = hevc->fbc_buffer_paddr[idx];
+		else
+			buf_y_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+
+		if (codec_hevc_use_fbc(sess)) {
+			val = buf_y_paddr | (idx << 8) | 1;
+			amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, val);
+		} else if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
+			buf_uv_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
+			val = buf_y_paddr | ((idx * 2) << 8) | 1;
+			amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, val);
+			val = buf_uv_paddr | ((idx * 2 + 1) << 8) | 1;
+			amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, val);
+		}
+	}
+
+	if (codec_hevc_use_fbc(sess))
+		val = buf_y_paddr | (idx << 8) | 1;
+	else
+		val = buf_y_paddr | ((idx * 2) << 8) | 1;
+
+	/* Fill the remaining unused slots with the last buffer's Y addr */
+	for (i = buf_num; i < MAX_REF_PIC_NUM; ++i)
+		amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, val);
+
+	amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 1);
+	amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, 1);
+	for (i = 0; i < 32; ++i)
+		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
+}
+
+static void codec_hevc_setup_buffers_gxl(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	struct v4l2_m2m_buffer *buf;
+	u32 buf_num = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
+	dma_addr_t buf_y_paddr = 0;
+	dma_addr_t buf_uv_paddr = 0;
+	int i;
+
+	amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, BIT(2) | BIT(1));
+
+	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
+		u32 idx = buf->vb.vb2_buf.index;
+
+		if (codec_hevc_use_downsample(sess))
+			buf_y_paddr = hevc->fbc_buffer_paddr[idx];
+		else
+			buf_y_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+
+		amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_DATA, buf_y_paddr >> 5);
+		if (!codec_hevc_use_fbc(sess)) {
+			buf_uv_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
+			amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_DATA, buf_uv_paddr >> 5);
+		}
+	}
+
+	/* Fill the remaining unused slots with the last buffer's Y addr */
+	for (i = buf_num; i < MAX_REF_PIC_NUM; ++i) {
+		amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_DATA, buf_y_paddr >> 5);
+		if (!codec_hevc_use_fbc(sess))
+			amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_DATA, buf_uv_paddr >> 5);
+	}
+
+	amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 1);
+	amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, 1);
+	for (i = 0; i < 32; ++i)
+		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
+}
+
+static void codec_hevc_free_fbc_buffers(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct device *dev = sess->core->dev;
+	int i;
+
+	for (i = 0; i < 24; ++i)
+		if (hevc->fbc_buffer_vaddr[i]) {
+			dma_free_coherent(dev, amvdec_am21c_size(sess->width, sess->height), hevc->fbc_buffer_vaddr[i], hevc->fbc_buffer_paddr[i]);
+			hevc->fbc_buffer_vaddr[i] = NULL;
+		}
+}
+
+static int codec_hevc_alloc_fbc_buffers(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct device *dev = sess->core->dev;
+	struct v4l2_m2m_buffer *buf;
+
+	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
+		u32 idx = buf->vb.vb2_buf.index;
+		hevc->fbc_buffer_vaddr[idx] = dma_alloc_coherent(dev, amvdec_am21c_size(sess->width, sess->height), &hevc->fbc_buffer_paddr[idx], GFP_KERNEL);
+		if (!hevc->fbc_buffer_vaddr[idx]) {
+			dev_err(dev, "Couldn't allocate FBC buffer %u\n", idx);
+			codec_hevc_free_fbc_buffers(sess);
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+static int codec_hevc_setup_buffers(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	int ret;
+
+	if (codec_hevc_use_downsample(sess)) {
+		ret = codec_hevc_alloc_fbc_buffers(sess);
+		if (ret)
+			return ret;
+	}
+
+	if (core->platform->revision == VDEC_REVISION_GXBB)
+		codec_hevc_setup_buffers_gxbb(sess);
+	else
+		codec_hevc_setup_buffers_gxl(sess);
+
+	return 0;
+}
+
+static int
+codec_hevc_setup_workspace(struct amvdec_core *core, struct codec_hevc *hevc)
+{
+	dma_addr_t wkaddr;
+
+	/* Allocate some memory for the HEVC decoder's state */
+	hevc->workspace_vaddr = dma_alloc_coherent(core->dev, SIZE_WORKSPACE, &wkaddr, GFP_KERNEL);
+	if (!hevc->workspace_vaddr) {
+		dev_err(core->dev, "Failed to allocate HEVC Workspace\n");
+		return -ENOMEM;
+	}
+
+	hevc->workspace_paddr = wkaddr;
+
+	amvdec_write_dos(core, HEVCD_IPP_LINEBUFF_BASE, wkaddr + IPP_OFFSET);
+	amvdec_write_dos(core, HEVC_RPM_BUFFER, wkaddr + RPM_OFFSET);
+	amvdec_write_dos(core, HEVC_SHORT_TERM_RPS, wkaddr + SH_TM_RPS_OFFSET);
+	amvdec_write_dos(core, HEVC_VPS_BUFFER, wkaddr + VPS_OFFSET);
+	amvdec_write_dos(core, HEVC_SPS_BUFFER, wkaddr + SPS_OFFSET);
+	amvdec_write_dos(core, HEVC_PPS_BUFFER, wkaddr + PPS_OFFSET);
+	amvdec_write_dos(core, HEVC_SAO_UP, wkaddr + SAO_UP_OFFSET);
+
+	/* No MMU */
+	amvdec_write_dos(core, HEVC_STREAM_SWAP_BUFFER,
+			 wkaddr + SWAP_BUF_OFFSET);
+	amvdec_write_dos(core, HEVC_STREAM_SWAP_BUFFER2,
+			 wkaddr + SWAP_BUF2_OFFSET);
+	amvdec_write_dos(core, HEVC_SCALELUT, wkaddr + SCALELUT_OFFSET);
+	amvdec_write_dos(core, HEVC_DBLK_CFG4, wkaddr + DBLK_PARA_OFFSET);
+	amvdec_write_dos(core, HEVC_DBLK_CFG5, wkaddr + DBLK_DATA_OFFSET);
+
+	return 0;
+}
+
+static int codec_hevc_start(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc;
+	int ret;
+	int i;
+
+	hevc = kzalloc(sizeof(*hevc), GFP_KERNEL);
+	if (!hevc)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&hevc->ref_frames_list);
+	hevc->curr_poc = INVALID_POC;
+
+	ret = codec_hevc_setup_workspace(core, hevc);
+	if (ret)
+		goto free_hevc;
+
+	amvdec_write_dos(core, HEVC_PARSER_VERSION, 0x5a5a55aa);
+	amvdec_write_dos(core, DOS_SW_RESET3, BIT(14));
+	amvdec_write_dos(core, HEVC_CABAC_CONTROL, 0);
+	amvdec_write_dos(core, HEVC_PARSER_CORE_CONTROL, 0);
+	amvdec_write_dos(core, HEVC_STREAM_CONTROL, amvdec_read_dos(core, HEVC_STREAM_CONTROL) | 1);
+	amvdec_write_dos(core, HEVC_SHIFT_STARTCODE, 0x00000100);
+	amvdec_write_dos(core, HEVC_SHIFT_EMULATECODE, 0x00000300);
+	writel_relaxed((amvdec_read_dos(core, HEVC_PARSER_INT_CONTROL) & 0x03ffffff) |
+			(3 << 29) | (2 << 26) | BIT(24) | BIT(22) | BIT(7) | BIT(4) | 1, core->dos_base + HEVC_PARSER_INT_CONTROL);
+	amvdec_write_dos(core, HEVC_SHIFT_STATUS, amvdec_read_dos(core, HEVC_SHIFT_STATUS) | BIT(1) | 1);
+	amvdec_write_dos(core, HEVC_SHIFT_CONTROL, (3 << 6) | (2 << 4) | (2 << 1) | 1);
+	amvdec_write_dos(core, HEVC_CABAC_CONTROL, 1);
+	amvdec_write_dos(core, HEVC_PARSER_CORE_CONTROL, 1);
+	amvdec_write_dos(core, HEVC_DEC_STATUS_REG, 0);
+
+	amvdec_write_dos(core, HEVC_IQIT_SCALELUT_WR_ADDR, 0);
+	for (i = 0; i < 1024; ++i)
+		amvdec_write_dos(core, HEVC_IQIT_SCALELUT_DATA, 0);
+
+	amvdec_write_dos(core, HEVC_DECODE_SIZE, 0);
+
+	amvdec_write_dos(core, HEVC_PARSER_CMD_WRITE, BIT(16));
+	for (i = 0; i < ARRAY_SIZE(parser_cmd); ++i)
+		amvdec_write_dos(core, HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
+
+	amvdec_write_dos(core, HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);
+	amvdec_write_dos(core, HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);
+	amvdec_write_dos(core, HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);
+	amvdec_write_dos(core, HEVC_PARSER_IF_CONTROL, BIT(5) | BIT(2) | 1);
+
+	amvdec_write_dos(core, HEVCD_IPP_TOP_CNTL, 1);
+	amvdec_write_dos(core, HEVCD_IPP_TOP_CNTL, BIT(1));
+
+	amvdec_write_dos(core, HEVC_WAIT_FLAG, 1);
+
+	/* clear mailbox interrupt */
+	amvdec_write_dos(core, HEVC_ASSIST_MBOX1_CLR_REG, 1);
+	/* enable mailbox interrupt */
+	amvdec_write_dos(core, HEVC_ASSIST_MBOX1_MASK, 1);
+	/* disable PSCALE for hardware sharing */
+	amvdec_write_dos(core, HEVC_PSCALE_CTRL, 0);
+	/* Let the uCode do all the parsing */
+	amvdec_write_dos(core, NAL_SEARCH_CTL, 0xc);
+
+	amvdec_write_dos(core, DECODE_STOP_POS, 0);
+	amvdec_write_dos(core, HEVC_DECODE_MODE, DECODE_MODE_SINGLE);
+	amvdec_write_dos(core, HEVC_DECODE_MODE2, 0);
+
+	/* AUX buffers */
+	hevc->aux_vaddr = dma_alloc_coherent(core->dev, SIZE_AUX, &hevc->aux_paddr, GFP_KERNEL);
+	if (!hevc->aux_vaddr) {
+		dev_err(core->dev, "Failed to request HEVC AUX\n");
+		ret = -ENOMEM;
+		goto free_hevc;
+	}
+
+	amvdec_write_dos(core, HEVC_AUX_ADR, hevc->aux_paddr);
+	amvdec_write_dos(core, HEVC_AUX_DATA_SIZE, (((SIZE_AUX) >> 4) << 16) | 0);
+	mutex_init(&hevc->lock);
+	sess->priv = hevc;
+
+	return 0;
+
+free_hevc:
+	kfree(hevc);
+	return ret;
+}
+
+static void codec_hevc_flush_output(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct hevc_frame *tmp;
+
+	while (!list_empty(&hevc->ref_frames_list)) {
+		tmp = codec_hevc_get_lowest_poc_frame(hevc);
+		amvdec_dst_buf_done(sess, tmp->vbuf, V4L2_FIELD_NONE);
+		list_del(&tmp->list);
+		kfree(tmp);
+		hevc->frames_num--;
+	}
+}
+
+static int codec_hevc_stop(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct amvdec_core *core = sess->core;
+
+	mutex_lock(&hevc->lock);
+	codec_hevc_flush_output(sess);
+
+	if (hevc->workspace_vaddr)
+		dma_free_coherent(core->dev, SIZE_WORKSPACE,
+				  hevc->workspace_vaddr,
+				  hevc->workspace_paddr);
+
+	if (hevc->frame_mmu_vaddr)
+		dma_free_coherent(core->dev, SIZE_FRAME_MMU,
+				  hevc->frame_mmu_vaddr,
+				  hevc->frame_mmu_paddr);
+
+	if (hevc->aux_vaddr)
+		dma_free_coherent(core->dev, SIZE_AUX,
+				  hevc->aux_vaddr, hevc->aux_paddr);
+
+	codec_hevc_free_fbc_buffers(sess);
+	mutex_unlock(&hevc->lock);
+	mutex_destroy(&hevc->lock);
+
+	return 0;
+}
+
+static void codec_hevc_update_tiles(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct amvdec_core *core = sess->core;
+	u32 sao_mem_unit = (hevc->lcu_size == 16 ? 9 : hevc->lcu_size == 32 ? 14 : 24) << 4;
+	u32 pic_height_cu = (hevc->height + hevc->lcu_size - 1) / hevc->lcu_size;
+	u32 pic_width_cu = (hevc->width + hevc->lcu_size - 1) / hevc->lcu_size;
+	u32 sao_vb_size = (sao_mem_unit + (2 << 4)) * pic_height_cu;
+	u32 tiles_flags = hevc->rpm_param.p.tiles_flags;
+
+	if (tiles_flags & 1) {
+		/* TODO; */
+		dev_err(core->dev, "Bitstream uses tiles, NotImplemented!\n");
+		return;
+	}
+
+	hevc->num_tile_col = 1;
+	hevc->num_tile_row = 1;
+	hevc->m_tile[0][0].width = pic_width_cu;
+	hevc->m_tile[0][0].height = pic_height_cu;
+	hevc->m_tile[0][0].start_cu_x = 0;
+	hevc->m_tile[0][0].start_cu_y = 0;
+	hevc->m_tile[0][0].sao_vb_start_addr = hevc->workspace_paddr + SAO_VB_OFFSET;
+	hevc->m_tile[0][0].sao_abv_start_addr = hevc->workspace_paddr + SAO_ABV_OFFSET;
+	
+	hevc->tile_start_lcu_x = 0;
+	hevc->tile_start_lcu_y = 0;
+	hevc->tile_width_lcu = pic_width_cu;
+	hevc->tile_height_lcu = pic_height_cu;
+
+	amvdec_write_dos(core, HEVC_sao_mem_unit, sao_mem_unit);
+	amvdec_write_dos(core, HEVC_SAO_ABV, hevc->workspace_paddr + SAO_ABV_OFFSET);
+	amvdec_write_dos(core, HEVC_sao_vb_size, sao_vb_size);
+	amvdec_write_dos(core, HEVC_SAO_VB, hevc->workspace_paddr + SAO_VB_OFFSET);
+}
+
+static struct hevc_frame * codec_hevc_get_frame_by_poc(struct codec_hevc *hevc, u32 poc)
+{
+	struct hevc_frame *tmp;
+
+	list_for_each_entry(tmp, &hevc->ref_frames_list, list) {
+		if (tmp->poc == poc)
+			return tmp;
+	}
+
+	return NULL;
+}
+
+static struct hevc_frame * codec_hevc_prepare_new_frame(struct amvdec_session *sess)
+{
+	struct vb2_v4l2_buffer *vbuf;
+	struct hevc_frame *new_frame = NULL;
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *params = &hevc->rpm_param;
+
+	new_frame = kzalloc(sizeof(*new_frame), GFP_KERNEL);
+	if (!new_frame)
+		return NULL;
+
+	vbuf = v4l2_m2m_dst_buf_remove(sess->m2m_ctx);
+	if (!vbuf) {
+		dev_err(sess->core->dev, "No dst buffer available\n");
+		return NULL;
+	}
+
+	new_frame->vbuf = vbuf;
+	new_frame->referenced = 1;
+	new_frame->poc = hevc->curr_poc;
+	new_frame->cur_slice_type = params->p.slice_type;
+	new_frame->num_reorder_pic = params->p.sps_num_reorder_pics_0;
+
+	list_add_tail(&new_frame->list, &hevc->ref_frames_list);
+	hevc->frames_num++;
+
+	return new_frame;
+}
+
+static void codec_hevc_set_sao(struct amvdec_session *sess, struct hevc_frame *frame)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *param = &hevc->rpm_param;
+	dma_addr_t buf_y_paddr;
+	dma_addr_t buf_u_v_paddr;
+	u32 misc_flag0 = param->p.misc_flag0;
+	u32 slice_deblocking_filter_disabled_flag;
+	u32 val, val_2;
+
+	val = (amvdec_read_dos(core, HEVC_SAO_CTRL0) & ~0xf) |
+	      ilog2(hevc->lcu_size);
+	amvdec_write_dos(core, HEVC_SAO_CTRL0, val);
+
+	amvdec_write_dos(core, HEVC_SAO_PIC_SIZE,
+			 hevc->width | (hevc->height << 16));
+	amvdec_write_dos(core, HEVC_SAO_PIC_SIZE_LCU,
+			 (hevc->lcu_x_num - 1) | (hevc->lcu_y_num - 1) << 16);
+
+	if (codec_hevc_use_downsample(sess))
+		buf_y_paddr =
+			hevc->fbc_buffer_paddr[frame->vbuf->vb2_buf.index];
+	else
+		buf_y_paddr =
+		       vb2_dma_contig_plane_dma_addr(&frame->vbuf->vb2_buf, 0);
+
+	if (codec_hevc_use_fbc(sess)) {
+		val = amvdec_read_dos(core, HEVC_SAO_CTRL5) & ~0xff0200;
+		amvdec_write_dos(core, HEVC_SAO_CTRL5, val);
+		amvdec_write_dos(core, HEVC_CM_BODY_START_ADDR, buf_y_paddr);
+	}
+
+	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
+		buf_y_paddr =
+		       vb2_dma_contig_plane_dma_addr(&frame->vbuf->vb2_buf, 0);
+		buf_u_v_paddr =
+		       vb2_dma_contig_plane_dma_addr(&frame->vbuf->vb2_buf, 1);
+		amvdec_write_dos(core, HEVC_SAO_Y_START_ADDR, buf_y_paddr);
+		amvdec_write_dos(core, HEVC_SAO_C_START_ADDR, buf_u_v_paddr);
+		amvdec_write_dos(core, HEVC_SAO_Y_WPTR, buf_y_paddr);
+		amvdec_write_dos(core, HEVC_SAO_C_WPTR, buf_u_v_paddr);
+	}
+
+	amvdec_write_dos(core, HEVC_SAO_Y_LENGTH, amvdec_get_output_size(sess));
+	amvdec_write_dos(core, HEVC_SAO_C_LENGTH,
+			 (amvdec_get_output_size(sess) / 2));
+
+	if (frame->cur_slice_idx == 0) {
+		amvdec_write_dos(core, HEVC_DBLK_CFG2, hevc->width | (hevc->height << 16));
+
+		val = 0;
+		if ((misc_flag0 >> PCM_ENABLE_FLAG_BIT) & 0x1)
+			val |= ((misc_flag0 >> PCM_LOOP_FILTER_DISABLED_FLAG_BIT) & 0x1) << 3;
+
+		val |= (param->p.pps_cb_qp_offset & 0x1f) << 4;
+		val |= (param->p.pps_cr_qp_offset & 0x1f) << 9;
+		val |= (hevc->lcu_size == 64) ? 0 : ((hevc->lcu_size == 32) ? 1 : 2);
+		amvdec_write_dos(core, HEVC_DBLK_CFG1, val);
+	}
+
+	val = amvdec_read_dos(core, HEVC_SAO_CTRL1) & ~0x3ff3;
+	val |= 0xff0; /* Set endianness for 2-bytes swaps (nv12) */
+	if (!codec_hevc_use_fbc(sess))
+		val |= BIT(0);   /* disable cm compression */
+	else if (sess->pixfmt_cap == V4L2_PIX_FMT_AM21C)
+		val |= BIT(1);     /* Disable double write */
+
+	amvdec_write_dos(core, HEVC_SAO_CTRL1, val);
+
+	if (!codec_hevc_use_fbc(sess)) {
+		/* no downscale for NV12 */
+		val = amvdec_read_dos(core, HEVC_SAO_CTRL5) & ~0xff0000;
+		amvdec_write_dos(core, HEVC_SAO_CTRL5, val);
+	}
+
+	val = amvdec_read_dos(core, HEVCD_IPP_AXIIF_CONFIG) & ~0x30;
+	val |= 0xf;
+	amvdec_write_dos(core, HEVCD_IPP_AXIIF_CONFIG, val);
+
+	val = 0;
+	val_2 = amvdec_read_dos(core, HEVC_SAO_CTRL0);
+	val_2 &= (~0x300);
+
+	/* TODO: handle tiles here if enabled */
+	slice_deblocking_filter_disabled_flag = (misc_flag0 >>
+			SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) & 0x1;
+	if ((misc_flag0 & (1 << DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT))
+		&& (misc_flag0 & (1 << DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT))) {
+		val |= slice_deblocking_filter_disabled_flag << 2;
+
+		if (!slice_deblocking_filter_disabled_flag) {
+			val |= (param->p.slice_beta_offset_div2 & 0xf) << 3;
+			val |= (param->p.slice_tc_offset_div2 & 0xf) << 7;
+		}
+	} else {
+		val |=
+			((misc_flag0 >>
+			  PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) & 0x1) << 2;
+
+		if (((misc_flag0 >> PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) &
+			 0x1) == 0) {
+			val |= (param->p.pps_beta_offset_div2 & 0xf) << 3;
+			val |= (param->p.pps_tc_offset_div2 & 0xf) << 7;
+		}
+	}
+	if ((misc_flag0 & (1 << PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT))
+		&& ((misc_flag0 & (1 << SLICE_SAO_LUMA_FLAG_BIT))
+			|| (misc_flag0 & (1 << SLICE_SAO_CHROMA_FLAG_BIT))
+			|| (!slice_deblocking_filter_disabled_flag))) {
+		val |=
+			((misc_flag0 >>
+			  SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			 & 0x1)	<< 1;
+		val_2 |=
+			((misc_flag0 >>
+			  SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			& 0x1) << 9;
+	} else {
+		val |=
+			((misc_flag0 >>
+			  PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			 & 0x1) << 1;
+		val_2 |=
+			((misc_flag0 >>
+			  PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			 & 0x1) << 9;
+	}
+
+	amvdec_write_dos(core, HEVC_DBLK_CFG9, val);
+	amvdec_write_dos(core, HEVC_SAO_CTRL0, val_2);
+}
+
+static dma_addr_t codec_hevc_get_frame_mv_paddr(struct codec_hevc *hevc, struct hevc_frame *frame)
+{
+	return hevc->workspace_paddr + MPRED_MV_OFFSET +
+		(frame->vbuf->vb2_buf.index * MPRED_MV_BUF_SIZE);
+}
+
+/* Update the necessary information for motion prediction with the current slice */
+static void codec_hevc_set_mpred(struct amvdec_session *sess, struct hevc_frame *frame, struct hevc_frame *col_frame)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 *ref_num = frame->ref_num;
+	u32 *ref_poc_l0 = frame->ref_poc_list[0][frame->cur_slice_idx];
+	u32 *ref_poc_l1 = frame->ref_poc_list[1][frame->cur_slice_idx];
+	u32 lcu_size_log2 = ilog2(hevc->lcu_size);
+	u32 mv_mem_unit = lcu_size_log2 == 6 ? 0x200 : lcu_size_log2 == 5 ? 0x80 : 0x20;
+	u32 slice_segment_address = param->p.slice_segment_address;
+	u32 max_num_merge_cand = 5 - param->p.five_minus_max_num_merge_cand;
+	u32 plevel = param->p.log2_parallel_merge_level;
+	u32 col_from_l0_flag = param->p.collocated_from_l0_flag;
+	u32 tmvp_flag = param->p.slice_temporal_mvp_enable_flag;
+	u32 is_next_slice_segment = param->p.dependent_slice_segment_flag ? 1 : 0;
+	u32 slice_type = param->p.slice_type;
+	dma_addr_t col_mv_rd_start_addr, col_mv_rd_ptr, col_mv_rd_end_addr;
+	dma_addr_t mpred_mv_wr_ptr;
+	u32 mv_rd_en = 1;
+	u32 val;
+	int i;
+
+	val = amvdec_read_dos(core, HEVC_MPRED_CURR_LCU);
+
+	col_mv_rd_start_addr = codec_hevc_get_frame_mv_paddr(hevc, col_frame);
+	mpred_mv_wr_ptr = codec_hevc_get_frame_mv_paddr(hevc, frame) + (hevc->slice_addr * mv_mem_unit);
+	col_mv_rd_ptr = col_mv_rd_start_addr + (hevc->slice_addr * mv_mem_unit);
+	col_mv_rd_end_addr = col_mv_rd_start_addr + ((hevc->lcu_x_num * hevc->lcu_y_num) * mv_mem_unit);
+
+	amvdec_write_dos(core, HEVC_MPRED_MV_WR_START_ADDR, codec_hevc_get_frame_mv_paddr(hevc, frame));
+	amvdec_write_dos(core, HEVC_MPRED_MV_RD_START_ADDR, col_mv_rd_start_addr);
+
+	val = ((hevc->lcu_x_num - hevc->tile_width_lcu) * mv_mem_unit);
+	amvdec_write_dos(core, HEVC_MPRED_MV_WR_ROW_JUMP, val);
+	amvdec_write_dos(core, HEVC_MPRED_MV_RD_ROW_JUMP, val);
+
+	if (slice_type == I_SLICE)
+		mv_rd_en = 0;
+
+	val = slice_type |
+	      BIT(3) | /* new tile */
+	      is_next_slice_segment << 4 |
+	      tmvp_flag << 5 |
+	      hevc->ldc_flag << 6 |
+	      col_from_l0_flag << 7 |
+	      BIT(9) |
+	      BIT(10) |
+	      mv_rd_en << 11 |
+	      BIT(13) |
+	      lcu_size_log2 << 16 |
+	      3 << 20 | plevel << 24;
+
+	if (slice_segment_address == 0)
+		val |= BIT(2); /* new frame */
+
+	amvdec_write_dos(core, HEVC_MPRED_CTRL0, val);
+
+	val = max_num_merge_cand | 2 << 4 | 3 << 8 | 5 << 12 | 36 << 16;
+	amvdec_write_dos(core, HEVC_MPRED_CTRL1, val);
+
+	amvdec_write_dos(core, HEVC_MPRED_PIC_SIZE, hevc->width | (hevc->height << 16));
+
+	val = ((hevc->lcu_x_num - 1) | (hevc->lcu_y_num - 1) << 16);
+	amvdec_write_dos(core, HEVC_MPRED_PIC_SIZE_LCU, val);
+	val = (hevc->tile_start_lcu_x | hevc->tile_start_lcu_y << 16);
+	amvdec_write_dos(core, HEVC_MPRED_TILE_START, val);
+	val = (hevc->tile_width_lcu | hevc->tile_height_lcu << 16);
+	amvdec_write_dos(core, HEVC_MPRED_TILE_SIZE_LCU, val);
+
+	amvdec_write_dos(core, HEVC_MPRED_REF_NUM, (ref_num[1] << 8) | ref_num[0]);
+	amvdec_write_dos(core, HEVC_MPRED_REF_EN_L0, (1 << ref_num[0]) - 1);
+	amvdec_write_dos(core, HEVC_MPRED_REF_EN_L1, (1 << ref_num[1]) - 1);
+
+	amvdec_write_dos(core, HEVC_MPRED_CUR_POC, hevc->curr_poc);
+	amvdec_write_dos(core, HEVC_MPRED_COL_POC, hevc->col_poc);
+
+	for (i = 0; i < MAX_REF_ACTIVE; ++i) {
+		amvdec_write_dos(core, HEVC_MPRED_L0_REF00_POC + i * 4, ref_poc_l0[i]);
+		amvdec_write_dos(core, HEVC_MPRED_L1_REF00_POC + i * 4, ref_poc_l1[i]);
+	}
+
+	if (slice_segment_address == 0) {
+		amvdec_write_dos(core, HEVC_MPRED_ABV_START_ADDR,
+				 hevc->workspace_paddr + MPRED_ABV_OFFSET);
+		amvdec_write_dos(core, HEVC_MPRED_MV_WPTR, mpred_mv_wr_ptr);
+		amvdec_write_dos(core, HEVC_MPRED_MV_RPTR, col_mv_rd_start_addr);
+	} else {
+		amvdec_write_dos(core, HEVC_MPRED_MV_RPTR, col_mv_rd_ptr);
+	}
+
+	amvdec_write_dos(core, HEVC_MPRED_MV_RD_END_ADDR, col_mv_rd_end_addr);
+}
+
+/*  motion compensation reference cache controller */
+static void codec_hevc_set_mcrcc(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	u32 val, val_2;
+	int l0_cnt = 0;
+	int l1_cnt = 0x7fff;
+
+	if (!codec_hevc_use_fbc(sess)) {
+		l0_cnt = hevc->cur_frame->ref_num[0];
+		l1_cnt = hevc->cur_frame->ref_num[1];
+	}
+
+	/* reset mcrcc */
+	amvdec_write_dos(core, HEVCD_MCRCC_CTL1, 0x02);
+
+	if (hevc->cur_frame->cur_slice_type == I_SLICE) {
+		/* remove reset -- disables clock */
+		amvdec_write_dos(core, HEVCD_MCRCC_CTL1, 0);
+		return;
+	}
+
+	if (hevc->cur_frame->cur_slice_type == P_SLICE) {
+		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, BIT(1));
+		val = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		val &= 0xffff;
+		val |= (val << 16);
+		amvdec_write_dos(core, HEVCD_MCRCC_CTL2, val);
+
+		if (l0_cnt == 1) {
+			amvdec_write_dos(core, HEVCD_MCRCC_CTL3, val);
+		} else {
+			val = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+			val &= 0xffff;
+			val |= (val << 16);
+			amvdec_write_dos(core, HEVCD_MCRCC_CTL3, val);
+		}
+	} else { /* B_SLICE */
+		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, 0);
+		val = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		val &= 0xffff;
+		val |= (val << 16);
+		amvdec_write_dos(core, HEVCD_MCRCC_CTL2, val);
+
+		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (16 << 8) | BIT(1));
+		val_2 = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		val_2 &= 0xffff;
+		val_2 |= (val_2 << 16);
+		if (val == val_2 && l1_cnt > 1) {
+			val_2 = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+			val_2 &= 0xffff;
+			val_2 |= (val_2 << 16);
+		}
+		amvdec_write_dos(core, HEVCD_MCRCC_CTL3, val);
+	}
+
+	/* enable mcrcc progressive-mode */
+	amvdec_write_dos(core, HEVCD_MCRCC_CTL1, 0xff0);
+}
+
+static void codec_hevc_set_ref_list(struct amvdec_session *sess,
+				u32 ref_num, u32 *ref_poc_list)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct hevc_frame *ref_frame;
+	struct amvdec_core *core = sess->core;
+	int i;
+	u32 buf_id_y;
+	u32 buf_id_uv;
+
+	for (i = 0; i < ref_num; i++) {
+		ref_frame = codec_hevc_get_frame_by_poc(hevc, ref_poc_list[i]);
+
+		if (!ref_frame) {
+			dev_warn(core->dev, "Couldn't find ref. frame %u\n",
+				ref_poc_list[i]);
+			continue;
+		}
+
+		if (codec_hevc_use_fbc(sess)) {
+			buf_id_y = buf_id_uv = ref_frame->vbuf->vb2_buf.index;
+		} else {
+			buf_id_y = ref_frame->vbuf->vb2_buf.index * 2;
+			buf_id_uv = buf_id_y + 1;
+		}
+
+		writel_relaxed((buf_id_uv << 16) |
+			       (buf_id_uv << 8) |
+			       buf_id_y,
+			       core->dos_base + HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+	}
+}
+
+static void codec_hevc_set_mc(struct amvdec_session *sess, struct hevc_frame *frame)
+{
+	struct amvdec_core *core = sess->core;
+
+	if (frame->cur_slice_type == I_SLICE)
+		return;
+
+	amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, 1);
+	codec_hevc_set_ref_list(sess, frame->ref_num[0],
+		frame->ref_poc_list[0][frame->cur_slice_idx]);
+
+	if (frame->cur_slice_type == P_SLICE)
+		return;
+
+	amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (16 << 8) | 1);
+	codec_hevc_set_ref_list(sess, frame->ref_num[1],
+		frame->ref_poc_list[1][frame->cur_slice_idx]);
+}
+
+static void codec_hevc_update_col_frame(struct codec_hevc *hevc)
+{
+	struct hevc_frame *cur_frame = hevc->cur_frame;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 list_no = 0;
+	u32 col_ref = param->p.collocated_ref_idx;
+	u32 col_from_l0 = param->p.collocated_from_l0_flag;
+
+	if (cur_frame->cur_slice_type == B_SLICE)
+		list_no = 1 - col_from_l0;
+
+	if (col_ref >= cur_frame->ref_num[list_no])
+		hevc->col_poc = INVALID_POC;
+	else
+		hevc->col_poc = cur_frame->ref_poc_list[list_no][cur_frame->cur_slice_idx][col_ref];
+
+	if (cur_frame->cur_slice_type == I_SLICE)
+		goto end;
+
+	if (hevc->col_poc != INVALID_POC)
+		hevc->col_frame = codec_hevc_get_frame_by_poc(hevc, hevc->col_poc);
+	else
+		hevc->col_frame = hevc->cur_frame;
+
+end:
+	if (!hevc->col_frame)
+		hevc->col_frame = hevc->cur_frame;
+}
+
+static void codec_hevc_update_pocs(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 nal_unit_type = param->p.m_nalUnitType;
+	u32 temporal_id = param->p.m_temporalId & 0x7;
+	int max_poc_lsb = 1 << (param->p.log2_max_pic_order_cnt_lsb_minus4 + 4);
+	int prev_poc_lsb;
+	int prev_poc_msb;
+	int poc_msb;
+	int poc_lsb = param->p.POClsb;
+
+	if (nal_unit_type == NAL_UNIT_CODED_SLICE_IDR ||
+	    nal_unit_type == NAL_UNIT_CODED_SLICE_IDR_N_LP) {
+		hevc->curr_poc = 0;
+		if ((temporal_id - 1) == 0)
+			hevc->iPrevTid0POC = hevc->curr_poc;
+
+		return;
+	}
+
+	prev_poc_lsb = hevc->iPrevTid0POC % max_poc_lsb;
+	prev_poc_msb = hevc->iPrevTid0POC - prev_poc_lsb;
+
+	if ((poc_lsb < prev_poc_lsb) && ((prev_poc_lsb - poc_lsb) >= (max_poc_lsb / 2)))
+		poc_msb = prev_poc_msb + max_poc_lsb;
+	else if ((poc_lsb > prev_poc_lsb) && ((poc_lsb - prev_poc_lsb) > (max_poc_lsb / 2)))
+		poc_msb = prev_poc_msb - max_poc_lsb;
+	else
+		poc_msb = prev_poc_msb;
+
+	if (nal_unit_type == NAL_UNIT_CODED_SLICE_BLA   ||
+	    nal_unit_type == NAL_UNIT_CODED_SLICE_BLANT ||
+	    nal_unit_type == NAL_UNIT_CODED_SLICE_BLA_N_LP)
+		poc_msb = 0;
+
+	hevc->curr_poc = (poc_msb + poc_lsb);
+	if ((temporal_id - 1) == 0)
+		hevc->iPrevTid0POC = hevc->curr_poc;
+}
+
+static void codec_hevc_process_segment_header(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *param = &hevc->rpm_param;
+
+	if (param->p.first_slice_segment_in_pic_flag == 0) {
+		hevc->slice_segment_addr = param->p.slice_segment_address;
+		if (!param->p.dependent_slice_segment_flag)
+			hevc->slice_addr = hevc->slice_segment_addr;
+	} else {
+		hevc->slice_segment_addr = 0;
+		hevc->slice_addr = 0;
+	}
+
+	codec_hevc_update_pocs(sess);
+}
+
+static int codec_hevc_process_segment(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct amvdec_core *core = sess->core;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 slice_segment_address = param->p.slice_segment_address;
+
+	/* First slice: new frame */
+	if (slice_segment_address == 0) {
+		codec_hevc_update_referenced(hevc);
+		codec_hevc_output_frames(sess);
+
+		hevc->cur_frame = codec_hevc_prepare_new_frame(sess);
+		if (!hevc->cur_frame)
+			return -1;
+
+		codec_hevc_update_tiles(sess);
+	} else {
+		hevc->cur_frame->cur_slice_idx++;
+	}
+
+	codec_hevc_update_frame_refs(sess, hevc->cur_frame);
+	codec_hevc_update_col_frame(hevc);
+	codec_hevc_update_ldc_flag(hevc);
+	codec_hevc_set_mc(sess, hevc->cur_frame);
+	codec_hevc_set_mcrcc(sess);
+	codec_hevc_set_mpred(sess, hevc->cur_frame, hevc->col_frame);
+	codec_hevc_set_sao(sess, hevc->cur_frame);
+
+	amvdec_write_dos(core, HEVC_WAIT_FLAG, amvdec_read_dos(core, HEVC_WAIT_FLAG) | 2);
+	amvdec_write_dos(core, HEVC_DEC_STATUS_REG, HEVC_CODED_SLICE_SEGMENT_DAT);
+
+	/* Interrupt the firmware's processor */
+	amvdec_write_dos(core, HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+
+	return 0;
+}
+
+static int codec_hevc_process_rpm(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *rpm_param = &hevc->rpm_param;
+	u32 lcu_x_num_div, lcu_y_num_div;
+
+	if (rpm_param->p.bit_depth)
+		hevc->is_10bit = 1;
+
+	hevc->width = rpm_param->p.pic_width_in_luma_samples;
+	hevc->height = rpm_param->p.pic_height_in_luma_samples;
+
+	/*if (hevc->width  != sess->width ||
+	    hevc->height != sess->height) {
+		dev_err(sess->core->dev_dec,
+			"Size mismatch: bitstream %ux%u ; driver %ux%u\n",
+			hevc->width, hevc->height,
+			sess->width, sess->height);
+		return -EINVAL;
+	}*/
+
+	hevc->lcu_size = 1 << (rpm_param->p.log2_min_coding_block_size_minus3 +
+		3 + rpm_param->p.log2_diff_max_min_coding_block_size);
+
+	lcu_x_num_div = (hevc->width / hevc->lcu_size);
+	lcu_y_num_div = (hevc->height / hevc->lcu_size);
+	hevc->lcu_x_num = ((hevc->width % hevc->lcu_size) == 0) ? lcu_x_num_div : lcu_x_num_div + 1;
+	hevc->lcu_y_num = ((hevc->height % hevc->lcu_size) == 0) ? lcu_y_num_div : lcu_y_num_div + 1;
+	hevc->lcu_total = hevc->lcu_x_num * hevc->lcu_y_num;
+
+	dev_dbg(core->dev, "lcu_size = %u ; lcu_x_num = %u; lcu_y_num = %u",
+		hevc->lcu_size, hevc->lcu_x_num, hevc->lcu_y_num);
+
+	return 0;
+}
+
+/* The RPM section within the workspace contains
+ * many information regarding the parsed bitstream
+ */
+static void codec_hevc_fetch_rpm(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	u16 *rpm_vaddr = hevc->workspace_vaddr + RPM_OFFSET;
+	int i, j;
+
+	for (i = 0; i < RPM_SIZE; i += 4)
+		for (j = 0; j < 4; j++)
+			hevc->rpm_param.l.data[i + j] = rpm_vaddr[i + 3 - j];
+}
+
+static irqreturn_t codec_hevc_threaded_isr(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc;
+
+	hevc = sess->priv;
+	if (!hevc)
+		return IRQ_HANDLED;
+
+	mutex_lock(&hevc->lock);
+	if (hevc->dec_status != HEVC_SLICE_SEGMENT_DONE) {
+		dev_err(core->dev_dec, "Unrecognized dec_status: %08X\n",
+			hevc->dec_status);
+		amvdec_abort(sess);
+		goto unlock;
+	}
+
+	sess->keyframe_found = 1;
+	codec_hevc_fetch_rpm(sess);
+	if (codec_hevc_process_rpm(sess)) {
+		amvdec_abort(sess);
+		goto unlock;
+	}
+
+	if (!hevc->is_buflist_init) {
+		if (codec_hevc_setup_buffers(sess)) {
+			amvdec_abort(sess);
+			goto unlock;
+		}
+
+		codec_hevc_setup_decode_head(sess);
+		hevc->is_buflist_init = 1;
+	}
+
+	codec_hevc_process_segment_header(sess);
+	if (codec_hevc_process_segment(sess))
+		amvdec_abort(sess);
+
+unlock:
+	mutex_unlock(&hevc->lock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t codec_hevc_isr(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+
+	hevc->dec_status = amvdec_read_dos(core, HEVC_DEC_STATUS_REG);
+
+	return IRQ_WAKE_THREAD;
+}
+
+struct amvdec_codec_ops codec_hevc_ops = {
+	.start = codec_hevc_start,
+	.stop = codec_hevc_stop,
+	.isr = codec_hevc_isr,
+	.threaded_isr = codec_hevc_threaded_isr,
+	.num_pending_bufs = codec_hevc_num_pending_bufs,
+	.drain = codec_hevc_flush_output,
+};
diff --git a/drivers/media/platform/meson/vdec/codec_hevc.h b/drivers/media/platform/meson/vdec/codec_hevc.h
new file mode 100644
index 0000000000000..5017e874e3ddc
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/codec_hevc.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2018 Maxime Jourdan <maxi.jourdan@wanadoo.fr>
+ */
+
+#ifndef __MESON_VDEC_CODEC_HEVC_H_
+#define __MESON_VDEC_CODEC_HEVC_H_
+
+#include "vdec.h"
+
+extern struct amvdec_codec_ops codec_hevc_ops;
+
+#endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/hevc_regs.h b/drivers/media/platform/meson/vdec/hevc_regs.h
new file mode 100644
index 0000000000000..ae9b38e463f7e
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/hevc_regs.h
@@ -0,0 +1,742 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef HEVC_REGS_HEADERS__
+#define HEVC_REGS_HEADERS__
+/*add from M8M2*/
+#define HEVC_ASSIST_AFIFO_CTRL (0x3001 * 4)
+#define HEVC_ASSIST_AFIFO_CTRL1 (0x3002 * 4)
+#define HEVC_ASSIST_GCLK_EN (0x3003 * 4)
+#define HEVC_ASSIST_SW_RESET (0x3004 * 4)
+#define HEVC_ASSIST_AMR1_INT0 (0x3025 * 4)
+#define HEVC_ASSIST_AMR1_INT1 (0x3026 * 4)
+#define HEVC_ASSIST_AMR1_INT2 (0x3027 * 4)
+#define HEVC_ASSIST_AMR1_INT3 (0x3028 * 4)
+#define HEVC_ASSIST_AMR1_INT4 (0x3029 * 4)
+#define HEVC_ASSIST_AMR1_INT5 (0x302a * 4)
+#define HEVC_ASSIST_AMR1_INT6 (0x302b * 4)
+#define HEVC_ASSIST_AMR1_INT7 (0x302c * 4)
+#define HEVC_ASSIST_AMR1_INT8 (0x302d * 4)
+#define HEVC_ASSIST_AMR1_INT9 (0x302e * 4)
+#define HEVC_ASSIST_AMR1_INTA (0x302f * 4)
+#define HEVC_ASSIST_AMR1_INTB (0x3030 * 4)
+#define HEVC_ASSIST_AMR1_INTC (0x3031 * 4)
+#define HEVC_ASSIST_AMR1_INTD (0x3032 * 4)
+#define HEVC_ASSIST_AMR1_INTE (0x3033 * 4)
+#define HEVC_ASSIST_AMR1_INTF (0x3034 * 4)
+#define HEVC_ASSIST_AMR2_INT0 (0x3035 * 4)
+#define HEVC_ASSIST_AMR2_INT1 (0x3036 * 4)
+#define HEVC_ASSIST_AMR2_INT2 (0x3037 * 4)
+#define HEVC_ASSIST_AMR2_INT3 (0x3038 * 4)
+#define HEVC_ASSIST_AMR2_INT4 (0x3039 * 4)
+#define HEVC_ASSIST_AMR2_INT5 (0x303a * 4)
+#define HEVC_ASSIST_AMR2_INT6 (0x303b * 4)
+#define HEVC_ASSIST_AMR2_INT7 (0x303c * 4)
+#define HEVC_ASSIST_AMR2_INT8 (0x303d * 4)
+#define HEVC_ASSIST_AMR2_INT9 (0x303e * 4)
+#define HEVC_ASSIST_AMR2_INTA (0x303f * 4)
+#define HEVC_ASSIST_AMR2_INTB (0x3040 * 4)
+#define HEVC_ASSIST_AMR2_INTC (0x3041 * 4)
+#define HEVC_ASSIST_AMR2_INTD (0x3042 * 4)
+#define HEVC_ASSIST_AMR2_INTE (0x3043 * 4)
+#define HEVC_ASSIST_AMR2_INTF (0x3044 * 4)
+#define HEVC_ASSIST_MBX_SSEL (0x3045 * 4)
+#define HEVC_ASSIST_TIMER0_LO (0x3060 * 4)
+#define HEVC_ASSIST_TIMER0_HI (0x3061 * 4)
+#define HEVC_ASSIST_TIMER1_LO (0x3062 * 4)
+#define HEVC_ASSIST_TIMER1_HI (0x3063 * 4)
+#define HEVC_ASSIST_DMA_INT (0x3064 * 4)
+#define HEVC_ASSIST_DMA_INT_MSK (0x3065 * 4)
+#define HEVC_ASSIST_DMA_INT2 (0x3066 * 4)
+#define HEVC_ASSIST_DMA_INT_MSK2 (0x3067 * 4)
+#define HEVC_ASSIST_MBOX0_IRQ_REG (0x3070 * 4)
+#define HEVC_ASSIST_MBOX0_CLR_REG (0x3071 * 4)
+#define HEVC_ASSIST_MBOX0_MASK (0x3072 * 4)
+#define HEVC_ASSIST_MBOX0_FIQ_SEL (0x3073 * 4)
+#define HEVC_ASSIST_MBOX1_IRQ_REG (0x3074 * 4)
+#define HEVC_ASSIST_MBOX1_CLR_REG (0x3075 * 4)
+#define HEVC_ASSIST_MBOX1_MASK (0x3076 * 4)
+#define HEVC_ASSIST_MBOX1_FIQ_SEL (0x3077 * 4)
+#define HEVC_ASSIST_MBOX2_IRQ_REG (0x3078 * 4)
+#define HEVC_ASSIST_MBOX2_CLR_REG (0x3079 * 4)
+#define HEVC_ASSIST_MBOX2_MASK (0x307a * 4)
+#define HEVC_ASSIST_MBOX2_FIQ_SEL (0x307b * 4)
+#define HEVC_ASSIST_AXI_CTRL (0x307c * 4)
+#define HEVC_ASSIST_AXI_STATUS (0x307d * 4)
+#define HEVC_ASSIST_SCRATCH_0 (0x30c0 * 4)
+#define HEVC_ASSIST_SCRATCH_1 (0x30c1 * 4)
+#define HEVC_ASSIST_SCRATCH_2 (0x30c2 * 4)
+#define HEVC_ASSIST_SCRATCH_3 (0x30c3 * 4)
+#define HEVC_ASSIST_SCRATCH_4 (0x30c4 * 4)
+#define HEVC_ASSIST_SCRATCH_5 (0x30c5 * 4)
+#define HEVC_ASSIST_SCRATCH_6 (0x30c6 * 4)
+#define HEVC_ASSIST_SCRATCH_7 (0x30c7 * 4)
+#define HEVC_ASSIST_SCRATCH_8 (0x30c8 * 4)
+#define HEVC_ASSIST_SCRATCH_9 (0x30c9 * 4)
+#define HEVC_ASSIST_SCRATCH_A (0x30ca * 4)
+#define HEVC_ASSIST_SCRATCH_B (0x30cb * 4)
+#define HEVC_ASSIST_SCRATCH_C (0x30cc * 4)
+#define HEVC_ASSIST_SCRATCH_D (0x30cd * 4)
+#define HEVC_ASSIST_SCRATCH_E (0x30ce * 4)
+#define HEVC_ASSIST_SCRATCH_F (0x30cf * 4)
+#define HEVC_ASSIST_SCRATCH_G (0x30d0 * 4)
+#define HEVC_ASSIST_SCRATCH_H (0x30d1 * 4)
+#define HEVC_ASSIST_SCRATCH_I (0x30d2 * 4)
+#define HEVC_ASSIST_SCRATCH_J (0x30d3 * 4)
+#define HEVC_ASSIST_SCRATCH_K (0x30d4 * 4)
+#define HEVC_ASSIST_SCRATCH_L (0x30d5 * 4)
+#define HEVC_ASSIST_SCRATCH_M (0x30d6 * 4)
+#define HEVC_ASSIST_SCRATCH_N (0x30d7 * 4)
+#define HEVC_PARSER_VERSION (0x3100 * 4)
+#define HEVC_STREAM_CONTROL (0x3101 * 4)
+#define HEVC_STREAM_START_ADDR (0x3102 * 4)
+#define HEVC_STREAM_END_ADDR (0x3103 * 4)
+#define HEVC_STREAM_WR_PTR (0x3104 * 4)
+#define HEVC_STREAM_RD_PTR (0x3105 * 4)
+#define HEVC_STREAM_LEVEL (0x3106 * 4)
+#define HEVC_STREAM_FIFO_CTL (0x3107 * 4)
+#define HEVC_SHIFT_CONTROL (0x3108 * 4)
+#define HEVC_SHIFT_STARTCODE (0x3109 * 4)
+#define HEVC_SHIFT_EMULATECODE (0x310a * 4)
+#define HEVC_SHIFT_STATUS (0x310b * 4)
+#define HEVC_SHIFTED_DATA (0x310c * 4)
+#define HEVC_SHIFT_BYTE_COUNT (0x310d * 4)
+#define HEVC_SHIFT_COMMAND (0x310e * 4)
+#define HEVC_ELEMENT_RESULT (0x310f * 4)
+#define HEVC_CABAC_CONTROL (0x3110 * 4)
+#define HEVC_PARSER_SLICE_INFO (0x3111 * 4)
+#define HEVC_PARSER_CMD_WRITE (0x3112 * 4)
+#define HEVC_PARSER_CORE_CONTROL (0x3113 * 4)
+#define HEVC_PARSER_CMD_FETCH (0x3114 * 4)
+#define HEVC_PARSER_CMD_STATUS (0x3115 * 4)
+#define HEVC_PARSER_LCU_INFO (0x3116 * 4)
+#define HEVC_PARSER_HEADER_INFO (0x3117 * 4)
+#define HEVC_PARSER_RESULT_0 (0x3118 * 4)
+#define HEVC_PARSER_RESULT_1 (0x3119 * 4)
+#define HEVC_PARSER_RESULT_2 (0x311a * 4)
+#define HEVC_PARSER_RESULT_3 (0x311b * 4)
+#define HEVC_CABAC_TOP_INFO (0x311c * 4)
+#define HEVC_CABAC_TOP_INFO_2 (0x311d * 4)
+#define HEVC_CABAC_LEFT_INFO (0x311e * 4)
+#define HEVC_CABAC_LEFT_INFO_2 (0x311f * 4)
+#define HEVC_PARSER_INT_CONTROL (0x3120 * 4)
+#define HEVC_PARSER_INT_STATUS (0x3121 * 4)
+#define HEVC_PARSER_IF_CONTROL (0x3122 * 4)
+#define HEVC_PARSER_PICTURE_SIZE (0x3123 * 4)
+#define HEVC_PARSER_LCU_START (0x3124 * 4)
+#define HEVC_PARSER_HEADER_INFO2 (0x3125 * 4)
+#define HEVC_PARSER_QUANT_READ (0x3126 * 4)
+#define HEVC_PARSER_RESERVED_27 (0x3127 * 4)
+#define HEVC_PARSER_CMD_SKIP_0 (0x3128 * 4)
+#define HEVC_PARSER_CMD_SKIP_1 (0x3129 * 4)
+#define HEVC_PARSER_CMD_SKIP_2 (0x312a * 4)
+#define HEVC_PARSER_MANUAL_CMD (0x312b * 4)
+#define HEVC_PARSER_MEM_RD_ADDR (0x312c * 4)
+#define HEVC_PARSER_MEM_WR_ADDR (0x312d * 4)
+#define HEVC_PARSER_MEM_RW_DATA (0x312e * 4)
+#define HEVC_SAO_IF_STATUS (0x3130 * 4)
+#define HEVC_SAO_IF_DATA_Y (0x3131 * 4)
+#define HEVC_SAO_IF_DATA_U (0x3132 * 4)
+#define HEVC_SAO_IF_DATA_V (0x3133 * 4)
+#define HEVC_STREAM_SWAP_ADDR (0x3134 * 4)
+#define HEVC_STREAM_SWAP_CTRL (0x3135 * 4)
+#define HEVC_IQIT_IF_WAIT_CNT (0x3136 * 4)
+#define HEVC_MPRED_IF_WAIT_CNT (0x3137 * 4)
+#define HEVC_SAO_IF_WAIT_CNT (0x3138 * 4)
+#define HEVC_PARSER_DEBUG_IDX (0x313e * 4)
+#define HEVC_PARSER_DEBUG_DAT (0x313f * 4)
+#define HEVC_MPRED_VERSION (0x3200 * 4)
+#define HEVC_MPRED_CTRL0 (0x3201 * 4)
+#define HEVC_MPRED_CTRL1 (0x3202 * 4)
+#define HEVC_MPRED_INT_EN (0x3203 * 4)
+#define HEVC_MPRED_INT_STATUS (0x3204 * 4)
+#define HEVC_MPRED_PIC_SIZE (0x3205 * 4)
+#define HEVC_MPRED_PIC_SIZE_LCU (0x3206 * 4)
+#define HEVC_MPRED_TILE_START (0x3207 * 4)
+#define HEVC_MPRED_TILE_SIZE_LCU (0x3208 * 4)
+#define HEVC_MPRED_REF_NUM (0x3209 * 4)
+#define HEVC_MPRED_LT_REF (0x320a * 4)
+#define HEVC_MPRED_LT_COLREF (0x320b * 4)
+#define HEVC_MPRED_REF_EN_L0 (0x320c * 4)
+#define HEVC_MPRED_REF_EN_L1 (0x320d * 4)
+#define HEVC_MPRED_COLREF_EN_L0 (0x320e * 4)
+#define HEVC_MPRED_COLREF_EN_L1 (0x320f * 4)
+#define HEVC_MPRED_AXI_WCTRL (0x3210 * 4)
+#define HEVC_MPRED_AXI_RCTRL (0x3211 * 4)
+#define HEVC_MPRED_ABV_START_ADDR (0x3212 * 4)
+#define HEVC_MPRED_MV_WR_START_ADDR (0x3213 * 4)
+#define HEVC_MPRED_MV_RD_START_ADDR (0x3214 * 4)
+#define HEVC_MPRED_MV_WPTR (0x3215 * 4)
+#define HEVC_MPRED_MV_RPTR (0x3216 * 4)
+#define HEVC_MPRED_MV_WR_ROW_JUMP (0x3217 * 4)
+#define HEVC_MPRED_MV_RD_ROW_JUMP (0x3218 * 4)
+#define HEVC_MPRED_CURR_LCU (0x3219 * 4)
+#define HEVC_MPRED_ABV_WPTR (0x321a * 4)
+#define HEVC_MPRED_ABV_RPTR (0x321b * 4)
+#define HEVC_MPRED_CTRL2 (0x321c * 4)
+#define HEVC_MPRED_CTRL3 (0x321d * 4)
+#define HEVC_MPRED_MV_WLCUY (0x321e * 4)
+#define HEVC_MPRED_MV_RLCUY (0x321f * 4)
+#define HEVC_MPRED_L0_REF00_POC (0x3220 * 4)
+#define HEVC_MPRED_L0_REF01_POC (0x3221 * 4)
+#define HEVC_MPRED_L0_REF02_POC (0x3222 * 4)
+#define HEVC_MPRED_L0_REF03_POC (0x3223 * 4)
+#define HEVC_MPRED_L0_REF04_POC (0x3224 * 4)
+#define HEVC_MPRED_L0_REF05_POC (0x3225 * 4)
+#define HEVC_MPRED_L0_REF06_POC (0x3226 * 4)
+#define HEVC_MPRED_L0_REF07_POC (0x3227 * 4)
+#define HEVC_MPRED_L0_REF08_POC (0x3228 * 4)
+#define HEVC_MPRED_L0_REF09_POC (0x3229 * 4)
+#define HEVC_MPRED_L0_REF10_POC (0x322a * 4)
+#define HEVC_MPRED_L0_REF11_POC (0x322b * 4)
+#define HEVC_MPRED_L0_REF12_POC (0x322c * 4)
+#define HEVC_MPRED_L0_REF13_POC (0x322d * 4)
+#define HEVC_MPRED_L0_REF14_POC (0x322e * 4)
+#define HEVC_MPRED_L0_REF15_POC (0x322f * 4)
+#define HEVC_MPRED_L1_REF00_POC (0x3230 * 4)
+#define HEVC_MPRED_L1_REF01_POC (0x3231 * 4)
+#define HEVC_MPRED_L1_REF02_POC (0x3232 * 4)
+#define HEVC_MPRED_L1_REF03_POC (0x3233 * 4)
+#define HEVC_MPRED_L1_REF04_POC (0x3234 * 4)
+#define HEVC_MPRED_L1_REF05_POC (0x3235 * 4)
+#define HEVC_MPRED_L1_REF06_POC (0x3236 * 4)
+#define HEVC_MPRED_L1_REF07_POC (0x3237 * 4)
+#define HEVC_MPRED_L1_REF08_POC (0x3238 * 4)
+#define HEVC_MPRED_L1_REF09_POC (0x3239 * 4)
+#define HEVC_MPRED_L1_REF10_POC (0x323a * 4)
+#define HEVC_MPRED_L1_REF11_POC (0x323b * 4)
+#define HEVC_MPRED_L1_REF12_POC (0x323c * 4)
+#define HEVC_MPRED_L1_REF13_POC (0x323d * 4)
+#define HEVC_MPRED_L1_REF14_POC (0x323e * 4)
+#define HEVC_MPRED_L1_REF15_POC (0x323f * 4)
+#define HEVC_MPRED_PIC_SIZE_EXT (0x3240 * 4)
+#define HEVC_MPRED_DBG_MODE0 (0x3241 * 4)
+#define HEVC_MPRED_DBG_MODE1 (0x3242 * 4)
+#define HEVC_MPRED_DBG2_MODE (0x3243 * 4)
+#define HEVC_MPRED_IMP_CMD0 (0x3244 * 4)
+#define HEVC_MPRED_IMP_CMD1 (0x3245 * 4)
+#define HEVC_MPRED_IMP_CMD2 (0x3246 * 4)
+#define HEVC_MPRED_IMP_CMD3 (0x3247 * 4)
+#define HEVC_MPRED_DBG2_DATA_0 (0x3248 * 4)
+#define HEVC_MPRED_DBG2_DATA_1 (0x3249 * 4)
+#define HEVC_MPRED_DBG2_DATA_2 (0x324a * 4)
+#define HEVC_MPRED_DBG2_DATA_3 (0x324b * 4)
+#define HEVC_MPRED_DBG_DATA_0 (0x3250 * 4)
+#define HEVC_MPRED_DBG_DATA_1 (0x3251 * 4)
+#define HEVC_MPRED_DBG_DATA_2 (0x3252 * 4)
+#define HEVC_MPRED_DBG_DATA_3 (0x3253 * 4)
+#define HEVC_MPRED_DBG_DATA_4 (0x3254 * 4)
+#define HEVC_MPRED_DBG_DATA_5 (0x3255 * 4)
+#define HEVC_MPRED_DBG_DATA_6 (0x3256 * 4)
+#define HEVC_MPRED_DBG_DATA_7 (0x3257 * 4)
+#define HEVC_MPRED_CUR_POC (0x3260 * 4)
+#define HEVC_MPRED_COL_POC (0x3261 * 4)
+#define HEVC_MPRED_MV_RD_END_ADDR (0x3262 * 4)
+#define HEVCD_IPP_TOP_CNTL (0x3400 * 4)
+#define HEVCD_IPP_TOP_STATUS (0x3401 * 4)
+#define HEVCD_IPP_TOP_FRMCONFIG (0x3402 * 4)
+#define HEVCD_IPP_TOP_TILECONFIG1 (0x3403 * 4)
+#define HEVCD_IPP_TOP_TILECONFIG2 (0x3404 * 4)
+#define HEVCD_IPP_TOP_TILECONFIG3 (0x3405 * 4)
+#define HEVCD_IPP_TOP_LCUCONFIG (0x3406 * 4)
+#define HEVCD_IPP_TOP_FRMCTL (0x3407 * 4)
+#define HEVCD_IPP_CONFIG (0x3408 * 4)
+#define HEVCD_IPP_LINEBUFF_BASE (0x3409 * 4)
+#define HEVCD_IPP_INTR_MASK (0x340a * 4)
+#define HEVCD_IPP_AXIIF_CONFIG (0x340b * 4)
+#define HEVCD_IPP_BITDEPTH_CONFIG (0x340c * 4)
+#define HEVCD_IPP_SWMPREDIF_CONFIG (0x3410 * 4)
+#define HEVCD_IPP_SWMPREDIF_STATUS (0x3411 * 4)
+#define HEVCD_IPP_SWMPREDIF_CTBINFO (0x3412 * 4)
+#define HEVCD_IPP_SWMPREDIF_PUINFO0 (0x3413 * 4)
+#define HEVCD_IPP_SWMPREDIF_PUINFO1 (0x3414 * 4)
+#define HEVCD_IPP_SWMPREDIF_PUINFO2 (0x3415 * 4)
+#define HEVCD_IPP_SWMPREDIF_PUINFO3 (0x3416 * 4)
+#define HEVCD_IPP_DYNCLKGATE_CONFIG (0x3420 * 4)
+#define HEVCD_IPP_DYNCLKGATE_STATUS (0x3421 * 4)
+#define HEVCD_IPP_DBG_SEL (0x3430 * 4)
+#define HEVCD_IPP_DBG_DATA (0x3431 * 4)
+#define HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR (0x3460 * 4)
+#define HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR (0x3461 * 4)
+#define HEVCD_MPP_ANC2AXI_TBL_WDATA_ADDR (0x3462 * 4)
+#define HEVCD_MPP_ANC2AXI_TBL_RDATA_ADDR (0x3463 * 4)
+#define HEVCD_MPP_WEIGHTPRED_CNTL_ADDR (0x347b * 4)
+#define HEVCD_MPP_L0_WEIGHT_FLAG_ADDR (0x347c * 4)
+#define HEVCD_MPP_L1_WEIGHT_FLAG_ADDR (0x347d * 4)
+#define HEVCD_MPP_YLOG2WGHTDENOM_ADDR (0x347e * 4)
+#define HEVCD_MPP_DELTACLOG2WGHTDENOM_ADDR (0x347f * 4)
+#define HEVCD_MPP_WEIGHT_ADDR (0x3480 * 4)
+#define HEVCD_MPP_WEIGHT_DATA (0x3481 * 4)
+#define HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR (0x34c0 * 4)
+#define HEVCD_MPP_ANC_CANVAS_DATA_ADDR (0x34c1 * 4)
+#define HEVCD_MPP_DECOMP_CTL1 (0x34c2 * 4)
+#define HEVCD_MPP_DECOMP_CTL2 (0x34c3 * 4)
+#define HEVCD_MCRCC_CTL1 (0x34f0 * 4)
+#define HEVCD_MCRCC_CTL2 (0x34f1 * 4)
+#define HEVCD_MCRCC_CTL3 (0x34f2 * 4)
+#define HEVCD_MCRCC_PERFMON_CTL (0x34f3 * 4)
+#define HEVCD_MCRCC_PERFMON_DATA (0x34f4 * 4)
+#define HEVC_DBLK_CFG0 (0x3500 * 4)
+#define HEVC_DBLK_CFG1 (0x3501 * 4)
+#define HEVC_DBLK_CFG2 (0x3502 * 4)
+#define HEVC_DBLK_CFG3 (0x3503 * 4)
+#define HEVC_DBLK_CFG4 (0x3504 * 4)
+#define HEVC_DBLK_CFG5 (0x3505 * 4)
+#define HEVC_DBLK_CFG6 (0x3506 * 4)
+#define HEVC_DBLK_CFG7 (0x3507 * 4)
+#define HEVC_DBLK_CFG8 (0x3508 * 4)
+#define HEVC_DBLK_CFG9 (0x3509 * 4)
+#define HEVC_DBLK_CFGA (0x350a * 4)
+#define HEVC_DBLK_STS0 (0x350b * 4)
+#define HEVC_DBLK_STS1 (0x350c * 4)
+#define HEVC_SAO_VERSION (0x3600 * 4)
+#define HEVC_SAO_CTRL0 (0x3601 * 4)
+#define HEVC_SAO_CTRL1 (0x3602 * 4)
+#define HEVC_SAO_INT_EN (0x3603 * 4)
+#define HEVC_SAO_INT_STATUS (0x3604 * 4)
+#define HEVC_SAO_PIC_SIZE (0x3605 * 4)
+#define HEVC_SAO_PIC_SIZE_LCU (0x3606 * 4)
+#define HEVC_SAO_TILE_START (0x3607 * 4)
+#define HEVC_SAO_TILE_SIZE_LCU (0x3608 * 4)
+#define HEVC_SAO_AXI_WCTRL (0x3609 * 4)
+#define HEVC_SAO_AXI_RCTRL (0x360a * 4)
+#define HEVC_SAO_Y_START_ADDR (0x360b * 4)
+#define HEVC_SAO_Y_LENGTH (0x360c * 4)
+#define HEVC_SAO_C_START_ADDR (0x360d * 4)
+#define HEVC_SAO_C_LENGTH (0x360e * 4)
+#define HEVC_SAO_Y_WPTR (0x360f * 4)
+#define HEVC_SAO_C_WPTR (0x3610 * 4)
+#define HEVC_SAO_ABV_START_ADDR (0x3611 * 4)
+#define HEVC_SAO_VB_WR_START_ADDR (0x3612 * 4)
+#define HEVC_SAO_VB_RD_START_ADDR (0x3613 * 4)
+#define HEVC_SAO_ABV_WPTR (0x3614 * 4)
+#define HEVC_SAO_ABV_RPTR (0x3615 * 4)
+#define HEVC_SAO_VB_WPTR (0x3616 * 4)
+#define HEVC_SAO_VB_RPTR (0x3617 * 4)
+#define HEVC_SAO_DBG_MODE0 (0x361e * 4)
+#define HEVC_SAO_DBG_MODE1 (0x361f * 4)
+#define HEVC_SAO_CTRL2 (0x3620 * 4)
+#define HEVC_SAO_CTRL3 (0x3621 * 4)
+#define HEVC_SAO_CTRL4 (0x3622 * 4)
+#define HEVC_SAO_CTRL5 (0x3623 * 4)
+#define HEVC_SAO_CTRL6 (0x3624 * 4)
+#define HEVC_SAO_CTRL7 (0x3625 * 4)
+#define HEVC_SAO_DBG_DATA_0 (0x3630 * 4)
+#define HEVC_SAO_DBG_DATA_1 (0x3631 * 4)
+#define HEVC_SAO_DBG_DATA_2 (0x3632 * 4)
+#define HEVC_SAO_DBG_DATA_3 (0x3633 * 4)
+#define HEVC_SAO_DBG_DATA_4 (0x3634 * 4)
+#define HEVC_SAO_DBG_DATA_5 (0x3635 * 4)
+#define HEVC_SAO_DBG_DATA_6 (0x3636 * 4)
+#define HEVC_SAO_DBG_DATA_7 (0x3637 * 4)
+#define HEVC_IQIT_CLK_RST_CTRL (0x3700 * 4)
+#define HEVC_IQIT_DEQUANT_CTRL (0x3701 * 4)
+#define HEVC_IQIT_SCALELUT_WR_ADDR (0x3702 * 4)
+#define HEVC_IQIT_SCALELUT_RD_ADDR (0x3703 * 4)
+#define HEVC_IQIT_SCALELUT_DATA (0x3704 * 4)
+#define HEVC_IQIT_SCALELUT_IDX_4 (0x3705 * 4)
+#define HEVC_IQIT_SCALELUT_IDX_8 (0x3706 * 4)
+#define HEVC_IQIT_SCALELUT_IDX_16_32 (0x3707 * 4)
+#define HEVC_IQIT_STAT_GEN0 (0x3708 * 4)
+#define HEVC_QP_WRITE (0x3709 * 4)
+#define HEVC_IQIT_STAT_GEN1 (0x370a * 4)
+/**/
+
+/*add from M8M2*/
+#define HEVC_MC_CTRL_REG (0x3900 * 4)
+#define HEVC_MC_MB_INFO (0x3901 * 4)
+#define HEVC_MC_PIC_INFO (0x3902 * 4)
+#define HEVC_MC_HALF_PEL_ONE (0x3903 * 4)
+#define HEVC_MC_HALF_PEL_TWO (0x3904 * 4)
+#define HEVC_POWER_CTL_MC (0x3905 * 4)
+#define HEVC_MC_CMD (0x3906 * 4)
+#define HEVC_MC_CTRL0 (0x3907 * 4)
+#define HEVC_MC_PIC_W_H (0x3908 * 4)
+#define HEVC_MC_STATUS0 (0x3909 * 4)
+#define HEVC_MC_STATUS1 (0x390a * 4)
+#define HEVC_MC_CTRL1 (0x390b * 4)
+#define HEVC_MC_MIX_RATIO0 (0x390c * 4)
+#define HEVC_MC_MIX_RATIO1 (0x390d * 4)
+#define HEVC_MC_DP_MB_XY (0x390e * 4)
+#define HEVC_MC_OM_MB_XY (0x390f * 4)
+#define HEVC_PSCALE_RST (0x3910 * 4)
+#define HEVC_PSCALE_CTRL (0x3911 * 4)
+#define HEVC_PSCALE_PICI_W (0x3912 * 4)
+#define HEVC_PSCALE_PICI_H (0x3913 * 4)
+#define HEVC_PSCALE_PICO_W (0x3914 * 4)
+#define HEVC_PSCALE_PICO_H (0x3915 * 4)
+#define HEVC_PSCALE_PICO_START_X (0x3916 * 4)
+#define HEVC_PSCALE_PICO_START_Y (0x3917 * 4)
+#define HEVC_PSCALE_DUMMY (0x3918 * 4)
+#define HEVC_PSCALE_FILT0_COEF0 (0x3919 * 4)
+#define HEVC_PSCALE_FILT0_COEF1 (0x391a * 4)
+#define HEVC_PSCALE_CMD_CTRL (0x391b * 4)
+#define HEVC_PSCALE_CMD_BLK_X (0x391c * 4)
+#define HEVC_PSCALE_CMD_BLK_Y (0x391d * 4)
+#define HEVC_PSCALE_STATUS (0x391e * 4)
+#define HEVC_PSCALE_BMEM_ADDR (0x391f * 4)
+#define HEVC_PSCALE_BMEM_DAT (0x3920 * 4)
+#define HEVC_PSCALE_DRAM_BUF_CTRL (0x3921 * 4)
+#define HEVC_PSCALE_MCMD_CTRL (0x3922 * 4)
+#define HEVC_PSCALE_MCMD_XSIZE (0x3923 * 4)
+#define HEVC_PSCALE_MCMD_YSIZE (0x3924 * 4)
+#define HEVC_PSCALE_RBUF_START_BLKX (0x3925 * 4)
+#define HEVC_PSCALE_RBUF_START_BLKY (0x3926 * 4)
+#define HEVC_PSCALE_PICO_SHIFT_XY (0x3928 * 4)
+#define HEVC_PSCALE_CTRL1 (0x3929 * 4)
+#define HEVC_PSCALE_SRCKEY_CTRL0 (0x392a * 4)
+#define HEVC_PSCALE_SRCKEY_CTRL1 (0x392b * 4)
+#define HEVC_PSCALE_CANVAS_RD_ADDR (0x392c * 4)
+#define HEVC_PSCALE_CANVAS_WR_ADDR (0x392d * 4)
+#define HEVC_PSCALE_CTRL2 (0x392e * 4)
+#define HEVC_HDEC_MC_OMEM_AUTO (0x3930 * 4)
+#define HEVC_HDEC_MC_MBRIGHT_IDX (0x3931 * 4)
+#define HEVC_HDEC_MC_MBRIGHT_RD (0x3932 * 4)
+#define HEVC_MC_MPORT_CTRL (0x3940 * 4)
+#define HEVC_MC_MPORT_DAT (0x3941 * 4)
+#define HEVC_MC_WT_PRED_CTRL (0x3942 * 4)
+#define HEVC_MC_MBBOT_ST_EVEN_ADDR (0x3944 * 4)
+#define HEVC_MC_MBBOT_ST_ODD_ADDR (0x3945 * 4)
+#define HEVC_MC_DPDN_MB_XY (0x3946 * 4)
+#define HEVC_MC_OMDN_MB_XY (0x3947 * 4)
+#define HEVC_MC_HCMDBUF_H (0x3948 * 4)
+#define HEVC_MC_HCMDBUF_L (0x3949 * 4)
+#define HEVC_MC_HCMD_H (0x394a * 4)
+#define HEVC_MC_HCMD_L (0x394b * 4)
+#define HEVC_MC_IDCT_DAT (0x394c * 4)
+#define HEVC_MC_CTRL_GCLK_CTRL (0x394d * 4)
+#define HEVC_MC_OTHER_GCLK_CTRL (0x394e * 4)
+#define HEVC_MC_CTRL2 (0x394f * 4)
+#define HEVC_MDEC_PIC_DC_CTRL (0x398e * 4)
+#define HEVC_MDEC_PIC_DC_STATUS (0x398f * 4)
+#define HEVC_ANC0_CANVAS_ADDR (0x3990 * 4)
+#define HEVC_ANC1_CANVAS_ADDR (0x3991 * 4)
+#define HEVC_ANC2_CANVAS_ADDR (0x3992 * 4)
+#define HEVC_ANC3_CANVAS_ADDR (0x3993 * 4)
+#define HEVC_ANC4_CANVAS_ADDR (0x3994 * 4)
+#define HEVC_ANC5_CANVAS_ADDR (0x3995 * 4)
+#define HEVC_ANC6_CANVAS_ADDR (0x3996 * 4)
+#define HEVC_ANC7_CANVAS_ADDR (0x3997 * 4)
+#define HEVC_ANC8_CANVAS_ADDR (0x3998 * 4)
+#define HEVC_ANC9_CANVAS_ADDR (0x3999 * 4)
+#define HEVC_ANC10_CANVAS_ADDR (0x399a * 4)
+#define HEVC_ANC11_CANVAS_ADDR (0x399b * 4)
+#define HEVC_ANC12_CANVAS_ADDR (0x399c * 4)
+#define HEVC_ANC13_CANVAS_ADDR (0x399d * 4)
+#define HEVC_ANC14_CANVAS_ADDR (0x399e * 4)
+#define HEVC_ANC15_CANVAS_ADDR (0x399f * 4)
+#define HEVC_ANC16_CANVAS_ADDR (0x39a0 * 4)
+#define HEVC_ANC17_CANVAS_ADDR (0x39a1 * 4)
+#define HEVC_ANC18_CANVAS_ADDR (0x39a2 * 4)
+#define HEVC_ANC19_CANVAS_ADDR (0x39a3 * 4)
+#define HEVC_ANC20_CANVAS_ADDR (0x39a4 * 4)
+#define HEVC_ANC21_CANVAS_ADDR (0x39a5 * 4)
+#define HEVC_ANC22_CANVAS_ADDR (0x39a6 * 4)
+#define HEVC_ANC23_CANVAS_ADDR (0x39a7 * 4)
+#define HEVC_ANC24_CANVAS_ADDR (0x39a8 * 4)
+#define HEVC_ANC25_CANVAS_ADDR (0x39a9 * 4)
+#define HEVC_ANC26_CANVAS_ADDR (0x39aa * 4)
+#define HEVC_ANC27_CANVAS_ADDR (0x39ab * 4)
+#define HEVC_ANC28_CANVAS_ADDR (0x39ac * 4)
+#define HEVC_ANC29_CANVAS_ADDR (0x39ad * 4)
+#define HEVC_ANC30_CANVAS_ADDR (0x39ae * 4)
+#define HEVC_ANC31_CANVAS_ADDR (0x39af * 4)
+#define HEVC_DBKR_CANVAS_ADDR (0x39b0 * 4)
+#define HEVC_DBKW_CANVAS_ADDR (0x39b1 * 4)
+#define HEVC_REC_CANVAS_ADDR (0x39b2 * 4)
+#define HEVC_CURR_CANVAS_CTRL (0x39b3 * 4)
+#define HEVC_MDEC_PIC_DC_THRESH (0x39b8 * 4)
+#define HEVC_MDEC_PICR_BUF_STATUS (0x39b9 * 4)
+#define HEVC_MDEC_PICW_BUF_STATUS (0x39ba * 4)
+#define HEVC_MCW_DBLK_WRRSP_CNT (0x39bb * 4)
+#define HEVC_MC_MBBOT_WRRSP_CNT (0x39bc * 4)
+#define HEVC_MDEC_PICW_BUF2_STATUS (0x39bd * 4)
+#define HEVC_WRRSP_FIFO_PICW_DBK (0x39be * 4)
+#define HEVC_WRRSP_FIFO_PICW_MC (0x39bf * 4)
+#define HEVC_AV_SCRATCH_0 (0x39c0 * 4)
+#define HEVC_AV_SCRATCH_1 (0x39c1 * 4)
+#define HEVC_AV_SCRATCH_2 (0x39c2 * 4)
+#define HEVC_AV_SCRATCH_3 (0x39c3 * 4)
+#define HEVC_AV_SCRATCH_4 (0x39c4 * 4)
+#define HEVC_AV_SCRATCH_5 (0x39c5 * 4)
+#define HEVC_AV_SCRATCH_6 (0x39c6 * 4)
+#define HEVC_AV_SCRATCH_7 (0x39c7 * 4)
+#define HEVC_AV_SCRATCH_8 (0x39c8 * 4)
+#define HEVC_AV_SCRATCH_9 (0x39c9 * 4)
+#define HEVC_AV_SCRATCH_A (0x39ca * 4)
+#define HEVC_AV_SCRATCH_B (0x39cb * 4)
+#define HEVC_AV_SCRATCH_C (0x39cc * 4)
+#define HEVC_AV_SCRATCH_D (0x39cd * 4)
+#define HEVC_AV_SCRATCH_E (0x39ce * 4)
+#define HEVC_AV_SCRATCH_F (0x39cf * 4)
+#define HEVC_AV_SCRATCH_G (0x39d0 * 4)
+#define HEVC_AV_SCRATCH_H (0x39d1 * 4)
+#define HEVC_AV_SCRATCH_I (0x39d2 * 4)
+#define HEVC_AV_SCRATCH_J (0x39d3 * 4)
+#define HEVC_AV_SCRATCH_K (0x39d4 * 4)
+#define HEVC_AV_SCRATCH_L (0x39d5 * 4)
+#define HEVC_AV_SCRATCH_M (0x39d6 * 4)
+#define HEVC_AV_SCRATCH_N (0x39d7 * 4)
+#define HEVC_WRRSP_CO_MB (0x39d8 * 4)
+#define HEVC_WRRSP_DCAC (0x39d9 * 4)
+#define HEVC_WRRSP_VLD (0x39da * 4)
+#define HEVC_MDEC_DOUBLEW_CFG0 (0x39db * 4)
+#define HEVC_MDEC_DOUBLEW_CFG1 (0x39dc * 4)
+#define HEVC_MDEC_DOUBLEW_CFG2 (0x39dd * 4)
+#define HEVC_MDEC_DOUBLEW_CFG3 (0x39de * 4)
+#define HEVC_MDEC_DOUBLEW_CFG4 (0x39df * 4)
+#define HEVC_MDEC_DOUBLEW_CFG5 (0x39e0 * 4)
+#define HEVC_MDEC_DOUBLEW_CFG6 (0x39e1 * 4)
+#define HEVC_MDEC_DOUBLEW_CFG7 (0x39e2 * 4)
+#define HEVC_MDEC_DOUBLEW_STATUS (0x39e3 * 4)
+#define HEVC_DBLK_RST (0x3950 * 4)
+#define HEVC_DBLK_CTRL (0x3951 * 4)
+#define HEVC_DBLK_MB_WID_HEIGHT (0x3952 * 4)
+#define HEVC_DBLK_STATUS (0x3953 * 4)
+#define HEVC_DBLK_CMD_CTRL (0x3954 * 4)
+#define HEVC_DBLK_MB_XY (0x3955 * 4)
+#define HEVC_DBLK_QP (0x3956 * 4)
+#define HEVC_DBLK_Y_BHFILT (0x3957 * 4)
+#define HEVC_DBLK_Y_BHFILT_HIGH (0x3958 * 4)
+#define HEVC_DBLK_Y_BVFILT (0x3959 * 4)
+#define HEVC_DBLK_CB_BFILT (0x395a * 4)
+#define HEVC_DBLK_CR_BFILT (0x395b * 4)
+#define HEVC_DBLK_Y_HFILT (0x395c * 4)
+#define HEVC_DBLK_Y_HFILT_HIGH (0x395d * 4)
+#define HEVC_DBLK_Y_VFILT (0x395e * 4)
+#define HEVC_DBLK_CB_FILT (0x395f * 4)
+#define HEVC_DBLK_CR_FILT (0x3960 * 4)
+#define HEVC_DBLK_BETAX_QP_SEL (0x3961 * 4)
+#define HEVC_DBLK_CLIP_CTRL0 (0x3962 * 4)
+#define HEVC_DBLK_CLIP_CTRL1 (0x3963 * 4)
+#define HEVC_DBLK_CLIP_CTRL2 (0x3964 * 4)
+#define HEVC_DBLK_CLIP_CTRL3 (0x3965 * 4)
+#define HEVC_DBLK_CLIP_CTRL4 (0x3966 * 4)
+#define HEVC_DBLK_CLIP_CTRL5 (0x3967 * 4)
+#define HEVC_DBLK_CLIP_CTRL6 (0x3968 * 4)
+#define HEVC_DBLK_CLIP_CTRL7 (0x3969 * 4)
+#define HEVC_DBLK_CLIP_CTRL8 (0x396a * 4)
+#define HEVC_DBLK_STATUS1 (0x396b * 4)
+#define HEVC_DBLK_GCLK_FREE (0x396c * 4)
+#define HEVC_DBLK_GCLK_OFF (0x396d * 4)
+#define HEVC_DBLK_AVSFLAGS (0x396e * 4)
+#define HEVC_DBLK_CBPY (0x3970 * 4)
+#define HEVC_DBLK_CBPY_ADJ (0x3971 * 4)
+#define HEVC_DBLK_CBPC (0x3972 * 4)
+#define HEVC_DBLK_CBPC_ADJ (0x3973 * 4)
+#define HEVC_DBLK_VHMVD (0x3974 * 4)
+#define HEVC_DBLK_STRONG (0x3975 * 4)
+#define HEVC_DBLK_RV8_QUANT (0x3976 * 4)
+#define HEVC_DBLK_CBUS_HCMD2 (0x3977 * 4)
+#define HEVC_DBLK_CBUS_HCMD1 (0x3978 * 4)
+#define HEVC_DBLK_CBUS_HCMD0 (0x3979 * 4)
+#define HEVC_DBLK_VLD_HCMD2 (0x397a * 4)
+#define HEVC_DBLK_VLD_HCMD1 (0x397b * 4)
+#define HEVC_DBLK_VLD_HCMD0 (0x397c * 4)
+#define HEVC_DBLK_OST_YBASE (0x397d * 4)
+#define HEVC_DBLK_OST_CBCRDIFF (0x397e * 4)
+#define HEVC_DBLK_CTRL1 (0x397f * 4)
+#define HEVC_MCRCC_CTL1 (0x3980 * 4)
+#define HEVC_MCRCC_CTL2 (0x3981 * 4)
+#define HEVC_MCRCC_CTL3 (0x3982 * 4)
+#define HEVC_GCLK_EN (0x3983 * 4)
+#define HEVC_MDEC_SW_RESET (0x3984 * 4)
+
+/*add from M8M2*/
+#define HEVC_VLD_STATUS_CTRL (0x3c00 * 4)
+#define HEVC_MPEG1_2_REG (0x3c01 * 4)
+#define HEVC_F_CODE_REG (0x3c02 * 4)
+#define HEVC_PIC_HEAD_INFO (0x3c03 * 4)
+#define HEVC_SLICE_VER_POS_PIC_TYPE (0x3c04 * 4)
+#define HEVC_QP_VALUE_REG (0x3c05 * 4)
+#define HEVC_MBA_INC (0x3c06 * 4)
+#define HEVC_MB_MOTION_MODE (0x3c07 * 4)
+#define HEVC_POWER_CTL_VLD (0x3c08 * 4)
+#define HEVC_MB_WIDTH (0x3c09 * 4)
+#define HEVC_SLICE_QP (0x3c0a * 4)
+#define HEVC_PRE_START_CODE (0x3c0b * 4)
+#define HEVC_SLICE_START_BYTE_01 (0x3c0c * 4)
+#define HEVC_SLICE_START_BYTE_23 (0x3c0d * 4)
+#define HEVC_RESYNC_MARKER_LENGTH (0x3c0e * 4)
+#define HEVC_DECODER_BUFFER_INFO (0x3c0f * 4)
+#define HEVC_FST_FOR_MV_X (0x3c10 * 4)
+#define HEVC_FST_FOR_MV_Y (0x3c11 * 4)
+#define HEVC_SCD_FOR_MV_X (0x3c12 * 4)
+#define HEVC_SCD_FOR_MV_Y (0x3c13 * 4)
+#define HEVC_FST_BAK_MV_X (0x3c14 * 4)
+#define HEVC_FST_BAK_MV_Y (0x3c15 * 4)
+#define HEVC_SCD_BAK_MV_X (0x3c16 * 4)
+#define HEVC_SCD_BAK_MV_Y (0x3c17 * 4)
+#define HEVC_VLD_DECODE_CONTROL (0x3c18 * 4)
+#define HEVC_VLD_REVERVED_19 (0x3c19 * 4)
+#define HEVC_VIFF_BIT_CNT (0x3c1a * 4)
+#define HEVC_BYTE_ALIGN_PEAK_HI (0x3c1b * 4)
+#define HEVC_BYTE_ALIGN_PEAK_LO (0x3c1c * 4)
+#define HEVC_NEXT_ALIGN_PEAK (0x3c1d * 4)
+#define HEVC_VC1_CONTROL_REG (0x3c1e * 4)
+#define HEVC_PMV1_X (0x3c20 * 4)
+#define HEVC_PMV1_Y (0x3c21 * 4)
+#define HEVC_PMV2_X (0x3c22 * 4)
+#define HEVC_PMV2_Y (0x3c23 * 4)
+#define HEVC_PMV3_X (0x3c24 * 4)
+#define HEVC_PMV3_Y (0x3c25 * 4)
+#define HEVC_PMV4_X (0x3c26 * 4)
+#define HEVC_PMV4_Y (0x3c27 * 4)
+#define HEVC_M4_TABLE_SELECT (0x3c28 * 4)
+#define HEVC_M4_CONTROL_REG (0x3c29 * 4)
+#define HEVC_BLOCK_NUM (0x3c2a * 4)
+#define HEVC_PATTERN_CODE (0x3c2b * 4)
+#define HEVC_MB_INFO (0x3c2c * 4)
+#define HEVC_VLD_DC_PRED (0x3c2d * 4)
+#define HEVC_VLD_ERROR_MASK (0x3c2e * 4)
+#define HEVC_VLD_DC_PRED_C (0x3c2f * 4)
+#define HEVC_LAST_SLICE_MV_ADDR (0x3c30 * 4)
+#define HEVC_LAST_MVX (0x3c31 * 4)
+#define HEVC_LAST_MVY (0x3c32 * 4)
+#define HEVC_VLD_C38 (0x3c38 * 4)
+#define HEVC_VLD_C39 (0x3c39 * 4)
+#define HEVC_VLD_STATUS (0x3c3a * 4)
+#define HEVC_VLD_SHIFT_STATUS (0x3c3b * 4)
+#define HEVC_VOFF_STATUS (0x3c3c * 4)
+#define HEVC_VLD_C3D (0x3c3d * 4)
+#define HEVC_VLD_DBG_INDEX (0x3c3e * 4)
+#define HEVC_VLD_DBG_DATA (0x3c3f * 4)
+#define HEVC_VLD_MEM_VIFIFO_START_PTR (0x3c40 * 4)
+#define HEVC_VLD_MEM_VIFIFO_CURR_PTR (0x3c41 * 4)
+#define HEVC_VLD_MEM_VIFIFO_END_PTR (0x3c42 * 4)
+#define HEVC_VLD_MEM_VIFIFO_BYTES_AVAIL (0x3c43 * 4)
+#define HEVC_VLD_MEM_VIFIFO_CONTROL (0x3c44 * 4)
+#define HEVC_VLD_MEM_VIFIFO_WP (0x3c45 * 4)
+#define HEVC_VLD_MEM_VIFIFO_RP (0x3c46 * 4)
+#define HEVC_VLD_MEM_VIFIFO_LEVEL (0x3c47 * 4)
+#define HEVC_VLD_MEM_VIFIFO_BUF_CNTL (0x3c48 * 4)
+#define HEVC_VLD_TIME_STAMP_CNTL (0x3c49 * 4)
+#define HEVC_VLD_TIME_STAMP_SYNC_0 (0x3c4a * 4)
+#define HEVC_VLD_TIME_STAMP_SYNC_1 (0x3c4b * 4)
+#define HEVC_VLD_TIME_STAMP_0 (0x3c4c * 4)
+#define HEVC_VLD_TIME_STAMP_1 (0x3c4d * 4)
+#define HEVC_VLD_TIME_STAMP_2 (0x3c4e * 4)
+#define HEVC_VLD_TIME_STAMP_3 (0x3c4f * 4)
+#define HEVC_VLD_TIME_STAMP_LENGTH (0x3c50 * 4)
+#define HEVC_VLD_MEM_VIFIFO_WRAP_COUNT (0x3c51 * 4)
+#define HEVC_VLD_MEM_VIFIFO_MEM_CTL (0x3c52 * 4)
+#define HEVC_VLD_MEM_VBUF_RD_PTR (0x3c53 * 4)
+#define HEVC_VLD_MEM_VBUF2_RD_PTR (0x3c54 * 4)
+#define HEVC_VLD_MEM_SWAP_ADDR (0x3c55 * 4)
+#define HEVC_VLD_MEM_SWAP_CTL (0x3c56 * 4)
+/**/
+
+/*add from M8M2*/
+#define HEVC_VCOP_CTRL_REG (0x3e00 * 4)
+#define HEVC_QP_CTRL_REG (0x3e01 * 4)
+#define HEVC_INTRA_QUANT_MATRIX (0x3e02 * 4)
+#define HEVC_NON_I_QUANT_MATRIX (0x3e03 * 4)
+#define HEVC_DC_SCALER (0x3e04 * 4)
+#define HEVC_DC_AC_CTRL (0x3e05 * 4)
+#define HEVC_DC_AC_SCALE_MUL (0x3e06 * 4)
+#define HEVC_DC_AC_SCALE_DIV (0x3e07 * 4)
+#define HEVC_POWER_CTL_IQIDCT (0x3e08 * 4)
+#define HEVC_RV_AI_Y_X (0x3e09 * 4)
+#define HEVC_RV_AI_U_X (0x3e0a * 4)
+#define HEVC_RV_AI_V_X (0x3e0b * 4)
+#define HEVC_RV_AI_MB_COUNT (0x3e0c * 4)
+#define HEVC_NEXT_INTRA_DMA_ADDRESS (0x3e0d * 4)
+#define HEVC_IQIDCT_CONTROL (0x3e0e * 4)
+#define HEVC_IQIDCT_DEBUG_INFO_0 (0x3e0f * 4)
+#define HEVC_DEBLK_CMD (0x3e10 * 4)
+#define HEVC_IQIDCT_DEBUG_IDCT (0x3e11 * 4)
+#define HEVC_DCAC_DMA_CTRL (0x3e12 * 4)
+#define HEVC_DCAC_DMA_ADDRESS (0x3e13 * 4)
+#define HEVC_DCAC_CPU_ADDRESS (0x3e14 * 4)
+#define HEVC_DCAC_CPU_DATA (0x3e15 * 4)
+#define HEVC_DCAC_MB_COUNT (0x3e16 * 4)
+#define HEVC_IQ_QUANT (0x3e17 * 4)
+#define HEVC_VC1_BITPLANE_CTL (0x3e18 * 4)
+
+
+/*add from M8M2*/
+#define HEVC_MSP (0x3300 * 4)
+#define HEVC_MPSR (0x3301 * 4)
+#define HEVC_MINT_VEC_BASE (0x3302 * 4)
+#define HEVC_MCPU_INTR_GRP (0x3303 * 4)
+#define HEVC_MCPU_INTR_MSK (0x3304 * 4)
+#define HEVC_MCPU_INTR_REQ (0x3305 * 4)
+#define HEVC_MPC_P (0x3306 * 4)
+#define HEVC_MPC_D (0x3307 * 4)
+#define HEVC_MPC_E (0x3308 * 4)
+#define HEVC_MPC_W (0x3309 * 4)
+#define HEVC_MINDEX0_REG (0x330a * 4)
+#define HEVC_MINDEX1_REG (0x330b * 4)
+#define HEVC_MINDEX2_REG (0x330c * 4)
+#define HEVC_MINDEX3_REG (0x330d * 4)
+#define HEVC_MINDEX4_REG (0x330e * 4)
+#define HEVC_MINDEX5_REG (0x330f * 4)
+#define HEVC_MINDEX6_REG (0x3310 * 4)
+#define HEVC_MINDEX7_REG (0x3311 * 4)
+#define HEVC_MMIN_REG (0x3312 * 4)
+#define HEVC_MMAX_REG (0x3313 * 4)
+#define HEVC_MBREAK0_REG (0x3314 * 4)
+#define HEVC_MBREAK1_REG (0x3315 * 4)
+#define HEVC_MBREAK2_REG (0x3316 * 4)
+#define HEVC_MBREAK3_REG (0x3317 * 4)
+#define HEVC_MBREAK_TYPE (0x3318 * 4)
+#define HEVC_MBREAK_CTRL (0x3319 * 4)
+#define HEVC_MBREAK_STAUTS (0x331a * 4)
+#define HEVC_MDB_ADDR_REG (0x331b * 4)
+#define HEVC_MDB_DATA_REG (0x331c * 4)
+#define HEVC_MDB_CTRL (0x331d * 4)
+#define HEVC_MSFTINT0 (0x331e * 4)
+#define HEVC_MSFTINT1 (0x331f * 4)
+#define HEVC_CSP (0x3320 * 4)
+#define HEVC_CPSR (0x3321 * 4)
+#define HEVC_CINT_VEC_BASE (0x3322 * 4)
+#define HEVC_CCPU_INTR_GRP (0x3323 * 4)
+#define HEVC_CCPU_INTR_MSK (0x3324 * 4)
+#define HEVC_CCPU_INTR_REQ (0x3325 * 4)
+#define HEVC_CPC_P (0x3326 * 4)
+#define HEVC_CPC_D (0x3327 * 4)
+#define HEVC_CPC_E (0x3328 * 4)
+#define HEVC_CPC_W (0x3329 * 4)
+#define HEVC_CINDEX0_REG (0x332a * 4)
+#define HEVC_CINDEX1_REG (0x332b * 4)
+#define HEVC_CINDEX2_REG (0x332c * 4)
+#define HEVC_CINDEX3_REG (0x332d * 4)
+#define HEVC_CINDEX4_REG (0x332e * 4)
+#define HEVC_CINDEX5_REG (0x332f * 4)
+#define HEVC_CINDEX6_REG (0x3330 * 4)
+#define HEVC_CINDEX7_REG (0x3331 * 4)
+#define HEVC_CMIN_REG (0x3332 * 4)
+#define HEVC_CMAX_REG (0x3333 * 4)
+#define HEVC_CBREAK0_REG (0x3334 * 4)
+#define HEVC_CBREAK1_REG (0x3335 * 4)
+#define HEVC_CBREAK2_REG (0x3336 * 4)
+#define HEVC_CBREAK3_REG (0x3337 * 4)
+#define HEVC_CBREAK_TYPE (0x3338 * 4)
+#define HEVC_CBREAK_CTRL (0x3339 * 4)
+#define HEVC_CBREAK_STAUTS (0x333a * 4)
+#define HEVC_CDB_ADDR_REG (0x333b * 4)
+#define HEVC_CDB_DATA_REG (0x333c * 4)
+#define HEVC_CDB_CTRL (0x333d * 4)
+#define HEVC_CSFTINT0 (0x333e * 4)
+#define HEVC_CSFTINT1 (0x333f * 4)
+#define HEVC_IMEM_DMA_CTRL (0x3340 * 4)
+#define HEVC_IMEM_DMA_ADR (0x3341 * 4)
+#define HEVC_IMEM_DMA_COUNT (0x3342 * 4)
+#define HEVC_WRRSP_IMEM (0x3343 * 4)
+#define HEVC_LMEM_DMA_CTRL (0x3350 * 4)
+#define HEVC_LMEM_DMA_ADR (0x3351 * 4)
+#define HEVC_LMEM_DMA_COUNT (0x3352 * 4)
+#define HEVC_WRRSP_LMEM (0x3353 * 4)
+#define HEVC_MAC_CTRL1 (0x3360 * 4)
+#define HEVC_ACC0REG1 (0x3361 * 4)
+#define HEVC_ACC1REG1 (0x3362 * 4)
+#define HEVC_MAC_CTRL2 (0x3370 * 4)
+#define HEVC_ACC0REG2 (0x3371 * 4)
+#define HEVC_ACC1REG2 (0x3372 * 4)
+#define HEVC_CPU_TRACE (0x3380 * 4)
+/**/
+
+#endif
+
diff --git a/drivers/media/platform/meson/vdec/vdec_hevc.c b/drivers/media/platform/meson/vdec/vdec_hevc.c
new file mode 100644
index 0000000000000..8872f58d39fea
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/vdec_hevc.c
@@ -0,0 +1,191 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Maxime Jourdan <maxi.jourdan@wanadoo.fr>
+ *
+ * VDEC_HEVC is a video decoding block that allows decoding of
+ * HEVC, VP9
+ */
+
+#include <linux/firmware.h>
+#include <linux/clk.h>
+
+#include "vdec_1.h"
+#include "vdec_helpers.h"
+#include "hevc_regs.h"
+#include "dos_regs.h"
+
+/* AO Registers */
+#define AO_RTI_GEN_PWR_SLEEP0	0xe8
+#define AO_RTI_GEN_PWR_ISO0	0xec
+	#define GEN_PWR_VDEC_HEVC (BIT(7) | BIT(6))
+
+#define MC_SIZE	(4096 * 4)
+
+static int vdec_hevc_load_firmware(struct amvdec_session *sess, const char* fwname)
+{
+	struct amvdec_core *core = sess->core;
+	struct device *dev = core->dev_dec;
+	const struct firmware *fw;
+	static void *mc_addr;
+	static dma_addr_t mc_addr_map;
+	int ret;
+	u32 i = 100;
+
+	ret = request_firmware(&fw, fwname, dev);
+	if (ret < 0)  {
+		dev_err(dev, "Unable to request firmware %s\n", fwname);
+		return ret;
+	}
+
+	if (fw->size < MC_SIZE) {
+		dev_err(dev, "Firmware size %zu is too small. Expected %u.\n",
+			fw->size, MC_SIZE);
+		ret = -EINVAL;
+		goto release_firmware;
+	}
+
+	mc_addr = dma_alloc_coherent(core->dev, MC_SIZE, &mc_addr_map, GFP_KERNEL);
+	if (!mc_addr) {
+		dev_err(dev, "Failed allocating memory for firmware loading\n");
+		ret = -ENOMEM;
+		goto release_firmware;
+	 }
+
+	memcpy(mc_addr, fw->data, MC_SIZE);
+
+	amvdec_write_dos(core, HEVC_MPSR, 0);
+	amvdec_write_dos(core, HEVC_CPSR, 0);
+
+	amvdec_write_dos(core, HEVC_IMEM_DMA_ADR, mc_addr_map);
+	amvdec_write_dos(core, HEVC_IMEM_DMA_COUNT, MC_SIZE / 4);
+	amvdec_write_dos(core, HEVC_IMEM_DMA_CTRL, (0x8000 | (7 << 16)));
+
+	while (--i && readl(core->dos_base + HEVC_IMEM_DMA_CTRL) & 0x8000) { }
+
+	if (i == 0) {
+		dev_err(dev, "Firmware load fail (DMA hang?)\n");
+		ret = -ENODEV;
+	}
+
+	dma_free_coherent(core->dev, MC_SIZE, mc_addr, mc_addr_map);
+release_firmware:
+	release_firmware(fw);
+	return ret;
+}
+
+static void vdec_hevc_stbuf_init(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+
+	amvdec_write_dos(core, HEVC_STREAM_CONTROL, amvdec_read_dos(core, HEVC_STREAM_CONTROL) & ~1);
+	amvdec_write_dos(core, HEVC_STREAM_START_ADDR, sess->vififo_paddr);
+	amvdec_write_dos(core, HEVC_STREAM_END_ADDR, sess->vififo_paddr + sess->vififo_size);
+	amvdec_write_dos(core, HEVC_STREAM_RD_PTR, sess->vififo_paddr);
+	amvdec_write_dos(core, HEVC_STREAM_WR_PTR, sess->vififo_paddr);
+}
+
+/* VDEC_HEVC specific ESPARSER configuration */
+static void vdec_hevc_conf_esparser(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+
+	/* set vififo_vbuf_rp_sel=>vdec_hevc */
+	amvdec_write_dos(core, DOS_GEN_CTRL0, 3 << 1);
+	amvdec_write_dos(core, HEVC_STREAM_CONTROL, amvdec_read_dos(core, HEVC_STREAM_CONTROL) | BIT(3));
+	amvdec_write_dos(core, HEVC_STREAM_CONTROL, amvdec_read_dos(core, HEVC_STREAM_CONTROL) | 1);
+	amvdec_write_dos(core, HEVC_STREAM_FIFO_CTL, amvdec_read_dos(core, HEVC_STREAM_FIFO_CTL) | BIT(29));
+}
+
+static u32 vdec_hevc_vififo_level(struct amvdec_session *sess)
+{
+	return readl_relaxed(sess->core->dos_base + HEVC_STREAM_LEVEL);
+}
+
+static int vdec_hevc_stop(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+
+	/* Disable interrupt */
+	amvdec_write_dos(core, HEVC_ASSIST_MBOX1_MASK, 0);
+	/* Disable firmware processor */
+	amvdec_write_dos(core, HEVC_MPSR, 0);
+
+	if (sess->priv)
+		codec_ops->stop(sess);
+
+	/* Enable VDEC_HEVC Isolation */
+	regmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_ISO0, 0xc00, 0xc00);
+
+	/* VDEC_HEVC Memories */
+	amvdec_write_dos(core, DOS_MEM_PD_HEVC, 0xffffffffUL);
+
+	regmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,
+		GEN_PWR_VDEC_HEVC, GEN_PWR_VDEC_HEVC);
+
+	clk_disable_unprepare(core->vdec_hevc_clk);
+
+	return 0;
+}
+
+static int vdec_hevc_start(struct amvdec_session *sess)
+{
+	int ret;
+	struct amvdec_core *core = sess->core;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+
+	clk_set_rate(core->vdec_hevc_clk, 666666666);
+	ret = clk_prepare_enable(core->vdec_hevc_clk);
+	if (ret)
+		return ret;
+
+	regmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_SLEEP0,
+		GEN_PWR_VDEC_HEVC, 0);
+	udelay(10);
+
+	/* Reset VDEC_HEVC*/
+	amvdec_write_dos(core, DOS_SW_RESET3, 0xffffffff);
+	amvdec_write_dos(core, DOS_SW_RESET3, 0x00000000);
+
+	amvdec_write_dos(core, DOS_GCLK_EN3, 0xffffffff);
+
+	/* VDEC_HEVC Memories */
+	amvdec_write_dos(core, DOS_MEM_PD_HEVC, 0x00000000);
+
+	/* Remove VDEC_HEVC Isolation */
+	regmap_update_bits(core->regmap_ao, AO_RTI_GEN_PWR_ISO0, 0xc00, 0);
+
+	amvdec_write_dos(core, DOS_SW_RESET3, 0xffffffff);
+	amvdec_write_dos(core, DOS_SW_RESET3, 0x00000000);
+
+	vdec_hevc_stbuf_init(sess);
+
+	ret = vdec_hevc_load_firmware(sess, sess->fmt_out->firmware_path);
+	if (ret)
+		goto stop;
+
+	ret = codec_ops->start(sess);
+	if (ret)
+		goto stop;
+
+	amvdec_write_dos(core, DOS_SW_RESET3, BIT(12)|BIT(11));
+	amvdec_write_dos(core, DOS_SW_RESET3, 0);
+	amvdec_read_dos(core, DOS_SW_RESET3);
+
+	amvdec_write_dos(core, HEVC_MPSR, 1);
+	/* Let the firmware settle */
+	udelay(10);
+
+	return 0;
+
+stop:
+	vdec_hevc_stop(sess);
+	return ret;
+}
+
+struct amvdec_ops vdec_hevc_ops = {
+	.start = vdec_hevc_start,
+	.stop = vdec_hevc_stop,
+	.conf_esparser = vdec_hevc_conf_esparser,
+	.vififo_level = vdec_hevc_vififo_level,
+};
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/vdec_hevc.h b/drivers/media/platform/meson/vdec/vdec_hevc.h
new file mode 100644
index 0000000000000..f1ccad7d5f949
--- /dev/null
+++ b/drivers/media/platform/meson/vdec/vdec_hevc.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2018 Maxime Jourdan <maxi.jourdan@wanadoo.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __MESON_VDEC_VDEC_HEVC_H_
+#define __MESON_VDEC_VDEC_HEVC_H_
+
+#include "vdec.h"
+
+extern struct amvdec_ops vdec_hevc_ops;
+
+#endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/vdec_platform.c b/drivers/media/platform/meson/vdec/vdec_platform.c
index 1181832b5fe1e..a8d03426e53d0 100644
--- a/drivers/media/platform/meson/vdec/vdec_platform.c
+++ b/drivers/media/platform/meson/vdec/vdec_platform.c
@@ -8,13 +8,25 @@
 #include "vdec.h"
 
 #include "vdec_1.h"
+#include "vdec_hevc.h"
 #include "codec_mpeg12.h"
 #include "codec_h264.h"
 #include "codec_mpeg4.h"
 #include "codec_mjpeg.h"
+#include "codec_hevc.h"
 
 static const struct amvdec_format vdec_formats_gxbb[] = {
 	{
+		.pixfmt = V4L2_PIX_FMT_HEVC,
+		.min_buffers = 16,
+		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
+		.vdec_ops = &vdec_hevc_ops,
+		.codec_ops = &codec_hevc_ops,
+		.firmware_path = "meson/gx/vh265_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_AM21C, 0 },
+	}, {
 		.pixfmt = V4L2_PIX_FMT_MJPEG,
 		.min_buffers = 4,
 		.max_buffers = 4,
@@ -89,6 +101,16 @@ static const struct amvdec_format vdec_formats_gxbb[] = {
 
 static const struct amvdec_format vdec_formats_gxl[] = {
 	{
+		.pixfmt = V4L2_PIX_FMT_HEVC,
+		.min_buffers = 16,
+		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
+		.vdec_ops = &vdec_hevc_ops,
+		.codec_ops = &codec_hevc_ops,
+		.firmware_path = "meson/gx/vh265_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_AM21C, 0 },
+	}, {
 		.pixfmt = V4L2_PIX_FMT_MJPEG,
 		.min_buffers = 4,
 		.max_buffers = 4,
@@ -163,6 +185,16 @@ static const struct amvdec_format vdec_formats_gxl[] = {
 
 static const struct amvdec_format vdec_formats_gxm[] = {
 	{
+		.pixfmt = V4L2_PIX_FMT_HEVC,
+		.min_buffers = 16,
+		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
+		.vdec_ops = &vdec_hevc_ops,
+		.codec_ops = &codec_hevc_ops,
+		.firmware_path = "meson/gx/vh265_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_AM21C, 0 },
+	}, {
 		.pixfmt = V4L2_PIX_FMT_MJPEG,
 		.min_buffers = 4,
 		.max_buffers = 4,
